/// A slice of a string.
///
/// When you create a slice of a string, a `Substring` instance is the result.
/// Operating on substrings is fast and efficient because a substring shares
/// its storage with the original string. The `Substring` type presents the
/// same interface as `String`, so you can avoid or defer any copying of the
/// string's contents.
///
/// The following example creates a `greeting` string, and then finds the
/// substring of the first sentence:
///
///     let greeting = "Hi there! It's nice to meet you! 👋"
///     let endOfSentence = greeting.firstIndex(of: "!")!
///     let firstSentence = greeting[...endOfSentence]
///     // firstSentence == "Hi there!"
///
/// You can perform many string operations on a substring. Here, we find the
/// length of the first sentence and create an uppercase version.
///
///     print("'\(firstSentence)' is \(firstSentence.count) characters long.")
///     // Prints "'Hi there!' is 9 characters long."
///
///     let shoutingSentence = firstSentence.uppercased()
///     // shoutingSentence == "HI THERE!"
///
/// Converting a Substring to a String
/// ==================================
///
/// This example defines a `rawData` string with some unstructured data, and
/// then uses the string's `prefix(while:)` method to create a substring of
/// the numeric prefix:
///
///     let rawInput = "126 a.b 22219 zzzzzz"
///     let numericPrefix = rawInput.prefix(while: { "0"..."9" ~= $0 })
///     // numericPrefix is the substring "126"
///
/// When you need to store a substring or pass it to a function that requires a
/// `String` instance, you can convert it to a `String` by using the
/// `String(_:)` initializer. Calling this initializer copies the contents of
/// the substring to a new string.
///
///     func parseAndAddOne(_ s: String) -> Int {
///         return Int(s, radix: 10)! + 1
///     }
///     _ = parseAndAddOne(numericPrefix)
///     // error: cannot convert value...
///     let incrementedPrefix = parseAndAddOne(String(numericPrefix))
///     // incrementedPrefix == 127
///
/// Alternatively, you can convert the function that takes a `String` to one
/// that is generic over the `StringProtocol` protocol. The following code
/// declares a generic version of the `parseAndAddOne(_:)` function:
///
///     func genericParseAndAddOne<S: StringProtocol>(_ s: S) -> Int {
///         return Int(s, radix: 10)! + 1
///     }
///     let genericallyIncremented = genericParseAndAddOne(numericPrefix)
///     // genericallyIncremented == 127
///
/// You can call this generic function with an instance of either `String` or
/// `Substring`.
///
/// - Important: Don't store substrings longer than you need them to perform a
///   specific operation. A substring holds a reference to the entire storage
///   of the string it comes from, not just to the portion it presents, even
///   when there is no other reference to the original string. Storing
///   substrings may, therefore, prolong the lifetime of string data that is
///   no longer otherwise accessible, which can appear to be memory leakage.
@frozen public struct Substring : Sendable {

    /// Creates an empty substring.
    @inlinable public init()

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(swift, deprecated: 4.2, message: "Substring.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    public static func ~= (lhs: Substring, rhs: String) -> Bool

    /// Creates a new instance from an interpolated string literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public init(stringInterpolation: DefaultStringInterpolation)

    /// Returns whether this string is capable of providing access to
    /// validly-encoded UTF-8 contents in contiguous memory in O(1) time.
    ///
    /// Contiguous strings always operate in O(1) time for withUTF8 and always
    /// give a result for String.UTF8View.withContiguousStorageIfAvailable.
    /// Contiguous strings also benefit from fast-paths and better optimizations.
    ///
    public var isContiguousUTF8: Bool { get }

    /// If this string is not contiguous, make it so. If this mutates the
    /// substring, it will invalidate any pre-existing indices.
    ///
    /// Complexity: O(n) if non-contiguous, O(1) if already contiguous
    ///
    public mutating func makeContiguousUTF8()

    /// Runs `body` over the content of this substring in contiguous memory. If
    /// this substring is not contiguous, this will first make it contiguous,
    /// which will also speed up subsequent access. If this mutates the substring,
    /// it will invalidate any pre-existing indices.
    ///
    /// Note that it is unsafe to escape the pointer provided to `body`. For
    /// example, strings of up to 15 UTF-8 code units in length may be represented
    /// in a small-string representation, and thus will be spilled into
    /// temporary stack space which is invalid after `withUTF8` finishes
    /// execution.
    ///
    /// Complexity: O(n) if non-contiguous, O(1) if already contiguous
    ///
    public mutating func withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R

    /// Returns the underlying string from which this substring was derived.
    public var base: String { get }

    @frozen public struct UTF8View : Sendable {
    }

    @inlinable public var utf8: Substring.UTF8View

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UTF8View)

    @frozen public struct UTF16View : Sendable {
    }

    @inlinable public var utf16: Substring.UTF16View

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UTF16View)

    @frozen public struct UnicodeScalarView : Sendable {
    }

    @inlinable public var unicodeScalars: Substring.UnicodeScalarView

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UnicodeScalarView)

    public func lowercased() -> String

    public func uppercased() -> String

    public func filter(_ isIncluded: (Substring.Element) throws -> Bool) rethrows -> String

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @available(swift 4)
    public subscript(r: Range<Substring.Index>) -> Substring { get }

    /// Removes and returns the last element of the collection.
    ///
    /// You can use `popLast()` to remove the last element of a collection that
    /// might be empty. The `removeLast()` method must be used only on a
    /// nonempty collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> Character?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty. To remove the last element of a
    /// collection that might be empty, use the `popLast()` method instead.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> Character

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to remove.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: Substring, maximum: Substring) -> ClosedRange<Substring>

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popFirst() -> Character?

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (Character) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (Character) throws -> Bool) rethrows -> Substring

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (Character) throws -> Bool) rethrows -> Substring

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.Index) -> Substring

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.Index) -> Substring

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.Index) -> Substring

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Character) throws -> Bool) rethrows -> [Substring]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: Character, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring]

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> Character

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: Character? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: Character) -> String.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (Character) throws -> Bool) rethrows -> String.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (Character) throws -> Bool) rethrows -> Character?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (Character) throws -> Bool) rethrows -> String.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: Character) -> String.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [Character] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [Character]

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: Substring, rhs: Substring) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: Substring, rhs: Substring) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: Substring, rhs: Substring) -> Bool

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: String)

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral value: String)

    /// Creates a new instance from an interpolated string literal.
    ///
    /// Don't call this initializer directly. It's used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     // message == "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public init(stringInterpolation: DefaultStringInterpolation)

    /// Applies the given difference to this collection.
    ///
    /// - Parameter difference: The difference to be applied.
    ///
    /// - Returns: An instance representing the state of the receiver with the
    ///   difference applied, or `nil` if the difference is incompatible with
    ///   the receiver's state.
    ///
    /// - Complexity: O(*n* + *c*), where *n* is `self.count` and *c* is the
    ///   number of changes contained by the parameter.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func applying(_ difference: CollectionDifference<Character>) -> Substring?

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, Character) -> Bool) -> CollectionDifference<Character> where C : BidirectionalCollection, Character == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<Character> where C : BidirectionalCollection, Character == C.Element

    public static func != (lhs: Substring, rhs: Substring) -> Bool

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: DefaultIndices<Substring> { get }

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Substring> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (Character) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: Character) -> String.Index?

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: Substring, maximum: Substring) -> Range<Substring>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: Substring) -> PartialRangeUpTo<Substring>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: Substring) -> PartialRangeThrough<Substring>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: Substring) -> PartialRangeFrom<Substring>

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring where R : RangeExpression, String.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring { get }

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    @inlinable public init(repeating repeatedValue: Character, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    @inlinable public init<S>(_ elements: S) where S : Sequence, Character == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many calls to `append(_:)` on the
    ///   same collection.
    @inlinable public mutating func append(_ newElement: Character)

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf newElements: S) where S : Sequence, Character == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection. If
    ///   `i == endIndex`, this method is equivalent to `append(_:)`.
    @inlinable public mutating func insert(_ newElement: Character, at i: String.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If `i == endIndex`, this method
    ///   is equivalent to `append(contentsOf:)`.
    @inlinable public mutating func insert<C>(contentsOf newElements: C, at i: String.Index) where C : Collection, Character == C.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   collection's end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func remove(at position: String.Index) -> Character

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange(_ bounds: Range<String.Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst() -> Character

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    @inlinable public mutating func reserveCapacity(_ n: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> Character

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, the complexity
    ///   is O(*m*).
    @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, Character == C.Element, String.Index == R.Bound

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, String.Index == R.Bound

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> Character?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> Character

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Creates a new collection by concatenating the elements of a collection and
    /// a sequence.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of an integer array and a `Range<Int>` instance.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let moreNumbers = numbers + (5...10)
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: A collection or finite sequence.
    @inlinable public static func + <Other>(lhs: Substring, rhs: Other) -> Substring where Other : Sequence, Character == Other.Element

    /// Creates a new collection by concatenating the elements of a sequence and a
    /// collection.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of a `Range<Int>` instance and an integer array.
    ///
    ///     let numbers = [7, 8, 9, 10]
    ///     let moreNumbers = (1...6) + numbers
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of argument on the right-hand side.
    /// In the example above, `moreNumbers` has the same type as `numbers`, which
    /// is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A collection or finite sequence.
    ///   - rhs: A range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Other, rhs: Substring) -> Substring where Other : Sequence, Character == Other.Element

    /// Appends the elements of a sequence to a range-replaceable collection.
    ///
    /// Use this operator to append the elements of a sequence to the end of
    /// range-replaceable collection with same `Element` type. This example
    /// appends the elements of a `Range<Int>` instance to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers += 10...15
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameters:
    ///   - lhs: The array to append to.
    ///   - rhs: A collection or finite sequence.
    ///
    /// - Complexity: O(*m*), where *m* is the length of the right-hand-side
    ///   argument.
    @inlinable public static func += <Other>(lhs: inout Substring, rhs: Other) where Other : Sequence, Character == Other.Element

    /// Creates a new collection by concatenating the elements of two collections.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of two integer arrays.
    ///
    ///     let lowerNumbers = [1, 2, 3, 4]
    ///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
    ///     let allNumbers = lowerNumbers + higherNumbers
    ///     print(allNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: Another range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Substring, rhs: Other) -> Substring where Other : RangeReplaceableCollection, Character == Other.Element

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. The order of the remaining elements is preserved.
    /// This example removes all the vowels from a string:
    ///
    ///     var phrase = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     phrase.removeAll(where: { vowels.contains($0) })
    ///     // phrase == "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter shouldBeRemoved: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(where shouldBeRemoved: (Character) throws -> Bool) rethrows

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Substring>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (Character) throws -> T) rethrows -> [T]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (Character) throws -> Void) rethrows

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> Character?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> Character?

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, Character == C.Element

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another regex match.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - subrange: The range in the collection in which to search for `regex`.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Output, Replacement>(_ regex: some RegexComponent, subrange: Range<String.Index>, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows -> Substring where Replacement : Collection, Replacement.Element == Character

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Output, Replacement>(_ regex: some RegexComponent, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows -> Substring where Replacement : Collection, Replacement.Element == Character

    /// Replaces all occurrences of the sequence matching the given regex with
    /// a given collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<Output, Replacement>(_ regex: some RegexComponent, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows where Replacement : Collection, Replacement.Element == Character

    /// Removes the initial elements that matches the given regex.
    /// - Parameter regex: The regex to remove from this collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(_ regex: some RegexComponent)

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, Character == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (Character) throws -> Bool) rethrows

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `regex`.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` in `subrange` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, subrange: Range<String.Index>, maxReplacements: Int = .max) -> Substring where Replacement : Collection, Replacement.Element == Character

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, maxReplacements: Int = .max) -> Substring where Replacement : Collection, Replacement.Element == Character

    /// Replaces all occurrences of the sequence matching the given regex with
    /// a given collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, maxReplacements: Int = .max) where Replacement : Collection, Replacement.Element == Character

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `other`.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, subrange: Range<String.Index>, maxReplacements: Int = .max) -> Substring where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) -> Substring where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Replaces all occurrences of a target sequence with a given collection
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, Character == C.Element

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.Index>] where C : Collection, Character == C.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (Character) throws -> Bool) rethrows -> Substring

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (Character) throws -> Bool) throws

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Character?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Character?

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring where Prefix : Sequence, Character == Prefix.Element

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Substring>

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Character>) throws -> R) rethrows -> R?

    /// Returns a collection containing all matches of the specified regex.
    /// - Parameter regex: The regex to search for.
    /// - Returns: A collection of matches of `regex`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func matches<Output>(of r: some RegexComponent) -> [Regex<Output>.Match]

    /// Returns the first match of the specified regex within the collection.
    /// - Parameter regex: The regex to search for.
    /// - Returns: The first match of `regex` in the collection, or `nil` if
    /// there isn't a match.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstMatch<Output>(of r: some RegexComponent) -> Regex<Output>.Match?

    /// Returns a new collection of the same type by removing `prefix` from the
    /// start.
    /// - Parameter prefix: The collection to remove from this collection.
    /// - Returns: A collection containing the elements that does not match
    /// `prefix` from the start.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(_ regex: some RegexComponent) -> Substring

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    ///
    /// - Parameter regex: The regex to search for.
    /// - Returns: A collection or ranges in the receiver of all occurrences of
    /// `regex`. Returns an empty collection if `regex` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges(of regex: some RegexComponent) -> [Range<String.Index>]

    /// Finds and returns the range of the first occurrence of a given regex
    /// within the collection.
    /// - Parameter regex: The regex to search for.
    /// - Returns: A range in the collection of the first occurrence of `regex`.
    /// Returns `nil` if `regex` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange(of regex: some RegexComponent) -> Range<String.Index>?

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (Character) throws -> Bool) rethrows -> Character?

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, Character == Prefix.Element

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Character, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Character == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Character, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (Character) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (Character) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: Character) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Character) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Character) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (Character) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (Character) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [Character]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> [Character]

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    @inlinable public static func != <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func >= <RHS>(lhs: Substring, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether the string begins with the
    /// specified prefix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let cafe = "Café du Monde"
    ///
    ///     // Case sensitive
    ///     print(cafe.hasPrefix("café"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode extended grapheme clusters
    /// rather than the code points used to compose them. The example below uses
    /// two strings with different forms of the `"é"` character---the first uses
    /// the composed form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "Café"
    ///     let decomposedCafe = "Cafe\u{0301}"
    ///
    ///     print(cafe.hasPrefix(composedCafe))
    ///     // Prints "true"
    ///     print(cafe.hasPrefix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter prefix: A possible prefix to test against this string.
    /// - Returns: `true` if the string begins with `prefix`; otherwise, `false`.
    @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where Prefix : StringProtocol

    /// Returns a Boolean value indicating whether the string ends with the
    /// specified suffix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let plans = "Let's meet at the café"
    ///
    ///     // Case sensitive
    ///     print(plans.hasSuffix("Café"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode extended grapheme clusters
    /// rather than the code points used to compose them. The example below uses
    /// two strings with different forms of the `"é"` character---the first uses
    /// the composed form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "café"
    ///     let decomposedCafe = "cafe\u{0301}"
    ///
    ///     print(plans.hasSuffix(composedCafe))
    ///     // Prints "true"
    ///     print(plans.hasSuffix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter suffix: A possible suffix to test against this string.
    /// - Returns: `true` if the string ends with `suffix`; otherwise, `false`.
    @inlinable public func hasSuffix<Suffix>(_ suffix: Suffix) -> Bool where Suffix : StringProtocol
}

/// Ambiguity breakers.
extension Substring {

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> Character?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> Character

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)
}

/// Default implementations of core requirements
extension Substring {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: Character? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Default implementation for bidirectional collections.
extension Substring {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout String.Index)
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Substring {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in the specified regex.
    ///
    /// - Parameter regex: A regex to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence matches the
    ///   beginning of `regex`; otherwise, `false`.
    public func starts(with regex: some RegexComponent) -> Bool
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Substring {

    /// Checks for a match against the string in its entirety.
    ///
    /// - Parameter r: The regular expression being matched.
    /// - Returns: The match, or `nil` if no match was found.
    public func wholeMatch<R>(of r: R) -> Regex<R.RegexOutput>.Match? where R : RegexComponent

    /// Checks for a match against the string, starting at its beginning.
    ///
    /// - Parameter r: The regular expression being matched.
    /// - Returns: The match, or `nil` if no match was found.
    public func prefixMatch<R>(of r: R) -> Regex<R.RegexOutput>.Match? where R : RegexComponent
}

/// Default implementation for forward collections.
extension Substring {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout String.Index)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int, limitedBy limit: String.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> Character? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> Character?
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Substring {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Substring>
}

extension Substring : StringProtocol {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Substring.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Substring.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Substring.Index) -> Substring.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Substring.Index) -> Substring.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: Substring.Index, offsetBy distance: Int) -> Substring.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: Substring.Index, offsetBy distance: Int, limitedBy limit: Substring.Index) -> Substring.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: Substring.Index, to end: Substring.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Substring.Index) -> Character { get }

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Substring.Index>, with newElements: C) where C : Collection, C.Element == Character

    public mutating func replaceSubrange(_ subrange: Range<Substring.Index>, with newElements: Substring)

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    @inlinable public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a string from the null-terminated, UTF-8 encoded sequence of
    /// bytes at the given pointer.
    ///
    /// - Parameter nullTerminatedUTF8: A pointer to a sequence of contiguous,
    ///   UTF-8 encoded bytes ending just before the first zero byte.
    public init(cString nullTerminatedUTF8: UnsafePointer<CChar>)

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    @inlinable public func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    @inlinable public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : _UnicodeEncoding

    /// A type representing the sequence's elements.
    public typealias Element = Character

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<Substring>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Substring>

    /// The type each segment of a string literal containing interpolations
    /// should be appended to.
    ///
    /// The `StringLiteralType` of an interpolation type must match the
    /// `StringLiteralType` of the conforming type.
    public typealias StringInterpolation = DefaultStringInterpolation

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

extension Substring : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension Substring : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

extension Substring : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension Substring : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init(_ content: String)
}

extension Substring : RangeReplaceableCollection {

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S>(_ elements: S) where S : Sequence, S.Element == Character

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf elements: S) where S : Sequence, S.Element == Character
}

extension Substring : TextOutputStream {

    /// Appends the given string to the stream.
    public mutating func write(_ other: String)
}

extension Substring : TextOutputStreamable {

    /// Writes a textual representation of this instance into the given output
    /// stream.
    @inlinable public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension Substring : ExpressibleByUnicodeScalarLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    @inlinable public init(unicodeScalarLiteral value: String)

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = String
}

extension Substring : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    @inlinable public init(extendedGraphemeClusterLiteral value: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = String
}

extension Substring : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    @inlinable public init(stringLiteral value: String)

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String
}

/// Default implementation for forward collections.
extension Substring.UTF8View {

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UTF8View.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UTF8View.Index, offsetBy distance: Int, limitedBy limit: String.UTF8View.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> String.UTF8View.Element? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> String.UTF8View.Element?
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Substring.UTF8View {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Substring.UTF8View>
}

extension Substring.UTF8View {

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popFirst() -> String.UTF8View.Element?

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UTF8View.Index>? where C : Collection, String.UTF8View.Element == C.Element

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UTF8View

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UTF8View

    /// Removes and returns the last element of the collection.
    ///
    /// You can use `popLast()` to remove the last element of a collection that
    /// might be empty. The `removeLast()` method must be used only on a
    /// nonempty collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> String.UTF8View.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty. To remove the last element of a
    /// collection that might be empty, use the `popLast()` method instead.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> String.UTF8View.Element

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to remove.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, String.UTF8View.Element == Prefix.Element

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UTF8View where Prefix : Sequence, String.UTF8View.Element == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (String.UTF8View.Element) throws -> Bool) throws

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> Substring.UTF8View

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UTF8View.Index>? where C : Collection, String.UTF8View.Element == C.Element

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.UTF8View.Index>] where C : Collection, String.UTF8View.Element == C.Element

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (String.UTF8View.Element) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UTF8View

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> Substring.UTF8View

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UTF8View

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> Substring.UTF8View

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.UTF8View.Index) -> Substring.UTF8View

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.UTF8View.Index) -> Substring.UTF8View

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.UTF8View.Index) -> Substring.UTF8View

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (String.UTF8View.Element) throws -> Bool) rethrows -> [Substring.UTF8View]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: String.UTF8View.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UTF8View]

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> String.UTF8View.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: String.UTF8View.Element? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: String.UTF8View.Element) -> String.UTF8View.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Element?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: String.UTF8View.Element) -> String.UTF8View.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [String.UTF8View.Element] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [String.UTF8View.Element]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, String.UTF8View.Element) -> Bool) -> CollectionDifference<String.UTF8View.Element> where C : BidirectionalCollection, String.UTF8View.Element == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<String.UTF8View.Element> where C : BidirectionalCollection, String.UTF8View.Element == C.Element

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Substring.UTF8View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (String.UTF8View.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: String.UTF8View.Element) -> String.UTF8View.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UTF8View where R : RangeExpression, String.UTF8View.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UTF8View { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Substring.UTF8View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (String.UTF8View.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (String.UTF8View.Element) throws -> Bool) rethrows -> [String.UTF8View.Element]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (String.UTF8View.Element) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Element?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<String.UTF8View.Element>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Substring.UTF8View>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (String.UTF8View.Element, String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Element?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (String.UTF8View.Element, String.UTF8View.Element) throws -> Bool) rethrows -> String.UTF8View.Element?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> String.UTF8View.Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> String.UTF8View.Element?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (String.UTF8View.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, String.UTF8View.Element == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (String.UTF8View.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UTF8View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (String.UTF8View.Element, String.UTF8View.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, String.UTF8View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UTF8View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (String.UTF8View.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: String.UTF8View.Element) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, String.UTF8View.Element) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, String.UTF8View.Element) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (String.UTF8View.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (String.UTF8View.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [String.UTF8View.Element]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (String.UTF8View.Element, String.UTF8View.Element) throws -> Bool) rethrows -> [String.UTF8View.Element]
}

/// Default implementations of core requirements
extension Substring.UTF8View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: String.UTF8View.Element? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Default implementation for bidirectional collections.
extension Substring.UTF8View {
}

extension Substring.UTF8View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.UTF8View.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = String.UTF8View.Indices

    /// A type representing the sequence's elements.
    public typealias Element = String.UTF8View.Element

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UTF8View

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Substring.UTF8View.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Substring.UTF8View.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(index: Substring.UTF8View.Index) -> Substring.UTF8View.Element { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: Substring.UTF8View.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable public func index(after i: Substring.UTF8View.Index) -> Substring.UTF8View.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Substring.UTF8View.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UTF8View.Index, offsetBy n: Int) -> Substring.UTF8View.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UTF8View.Index, offsetBy n: Int, limitedBy limit: Substring.UTF8View.Index) -> Substring.UTF8View.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @inlinable public func distance(from start: Substring.UTF8View.Index, to end: Substring.UTF8View.Index) -> Int

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Substring.UTF8View.Element>) throws -> R) rethrows -> R?

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before i: Substring.UTF8View.Index) -> Substring.UTF8View.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Substring.UTF8View.Index)

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(r: Range<Substring.UTF8View.Index>) -> Substring.UTF8View { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Substring.UTF8View>
}

/// Default implementation for bidirectional collections.
extension Substring.UTF16View {
}

extension Substring.UTF16View {

    /// Removes and returns the last element of the collection.
    ///
    /// You can use `popLast()` to remove the last element of a collection that
    /// might be empty. The `removeLast()` method must be used only on a
    /// nonempty collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> String.UTF16View.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty. To remove the last element of a
    /// collection that might be empty, use the `popLast()` method instead.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> String.UTF16View.Element

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to remove.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, String.UTF16View.Element == Prefix.Element

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UTF16View where Prefix : Sequence, String.UTF16View.Element == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (String.UTF16View.Element) throws -> Bool) throws

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> Substring.UTF16View

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.UTF16View.Index>] where C : Collection, String.UTF16View.Element == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UTF16View.Index>? where C : Collection, String.UTF16View.Element == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UTF16View.Index>? where C : Collection, String.UTF16View.Element == C.Element

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UTF16View

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UTF16View

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popFirst() -> String.UTF16View.Element?

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (String.UTF16View.Element) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UTF16View

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> Substring.UTF16View

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UTF16View

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> Substring.UTF16View

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.UTF16View.Index) -> Substring.UTF16View

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.UTF16View.Index) -> Substring.UTF16View

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.UTF16View.Index) -> Substring.UTF16View

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (String.UTF16View.Element) throws -> Bool) rethrows -> [Substring.UTF16View]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: String.UTF16View.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UTF16View]

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> String.UTF16View.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: String.UTF16View.Element? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: String.UTF16View.Element) -> String.UTF16View.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Element?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: String.UTF16View.Element) -> String.UTF16View.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [String.UTF16View.Element] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [String.UTF16View.Element]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, String.UTF16View.Element) -> Bool) -> CollectionDifference<String.UTF16View.Element> where C : BidirectionalCollection, String.UTF16View.Element == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<String.UTF16View.Element> where C : BidirectionalCollection, String.UTF16View.Element == C.Element

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Substring.UTF16View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (String.UTF16View.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: String.UTF16View.Element) -> String.UTF16View.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UTF16View where R : RangeExpression, String.UTF16View.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UTF16View { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Substring.UTF16View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (String.UTF16View.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (String.UTF16View.Element) throws -> Bool) rethrows -> [String.UTF16View.Element]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (String.UTF16View.Element) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Element?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<String.UTF16View.Element>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Substring.UTF16View>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (String.UTF16View.Element, String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Element?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (String.UTF16View.Element, String.UTF16View.Element) throws -> Bool) rethrows -> String.UTF16View.Element?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> String.UTF16View.Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> String.UTF16View.Element?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (String.UTF16View.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, String.UTF16View.Element == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (String.UTF16View.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UTF16View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (String.UTF16View.Element, String.UTF16View.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, String.UTF16View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UTF16View.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (String.UTF16View.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: String.UTF16View.Element) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, String.UTF16View.Element) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, String.UTF16View.Element) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (String.UTF16View.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (String.UTF16View.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [String.UTF16View.Element]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (String.UTF16View.Element, String.UTF16View.Element) throws -> Bool) rethrows -> [String.UTF16View.Element]
}

/// Default implementation for forward collections.
extension Substring.UTF16View {

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UTF16View.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UTF16View.Index, offsetBy distance: Int, limitedBy limit: String.UTF16View.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> String.UTF16View.Element? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> String.UTF16View.Element?
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Substring.UTF16View {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Substring.UTF16View>
}

/// Default implementations of core requirements
extension Substring.UTF16View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: String.UTF16View.Element? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

extension Substring.UTF16View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.UTF16View.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = String.UTF16View.Indices

    /// A type representing the sequence's elements.
    public typealias Element = String.UTF16View.Element

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UTF16View

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Substring.UTF16View.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Substring.UTF16View.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(index: Substring.UTF16View.Index) -> Substring.UTF16View.Element { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: Substring.UTF16View.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable public func index(after i: Substring.UTF16View.Index) -> Substring.UTF16View.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Substring.UTF16View.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UTF16View.Index, offsetBy n: Int) -> Substring.UTF16View.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UTF16View.Index, offsetBy n: Int, limitedBy limit: Substring.UTF16View.Index) -> Substring.UTF16View.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @inlinable public func distance(from start: Substring.UTF16View.Index, to end: Substring.UTF16View.Index) -> Int

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before i: Substring.UTF16View.Index) -> Substring.UTF16View.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Substring.UTF16View.Index)

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(r: Range<Substring.UTF16View.Index>) -> Substring.UTF16View { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Substring.UTF16View>
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Substring.UnicodeScalarView {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Substring.UnicodeScalarView>
}

/// Default implementation for bidirectional collections.
extension Substring.UnicodeScalarView {
}

extension Substring.UnicodeScalarView {

    /// Removes and returns the last element of the collection.
    ///
    /// You can use `popLast()` to remove the last element of a collection that
    /// might be empty. The `removeLast()` method must be used only on a
    /// nonempty collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> String.UnicodeScalarView.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty. To remove the last element of a
    /// collection that might be empty, use the `popLast()` method instead.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> String.UnicodeScalarView.Element

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to remove.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UnicodeScalarView

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UnicodeScalarView

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popFirst() -> String.UnicodeScalarView.Element?

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (String.UnicodeScalarView.Element) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UnicodeScalarView

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UnicodeScalarView

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.UnicodeScalarView.Index) -> Substring.UnicodeScalarView

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.UnicodeScalarView.Index) -> Substring.UnicodeScalarView

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.UnicodeScalarView.Index) -> Substring.UnicodeScalarView

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> [Substring.UnicodeScalarView]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: String.UnicodeScalarView.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UnicodeScalarView]

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> String.UnicodeScalarView.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove. `k` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: String.UnicodeScalarView.Element? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: String.UnicodeScalarView.Element) -> String.UnicodeScalarView.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Element?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: String.UnicodeScalarView.Element) -> String.UnicodeScalarView.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [String.UnicodeScalarView.Element] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [String.UnicodeScalarView.Element]

    /// Applies the given difference to this collection.
    ///
    /// - Parameter difference: The difference to be applied.
    ///
    /// - Returns: An instance representing the state of the receiver with the
    ///   difference applied, or `nil` if the difference is incompatible with
    ///   the receiver's state.
    ///
    /// - Complexity: O(*n* + *c*), where *n* is `self.count` and *c* is the
    ///   number of changes contained by the parameter.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func applying(_ difference: CollectionDifference<String.UnicodeScalarView.Element>) -> Substring.UnicodeScalarView?

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, String.UnicodeScalarView.Element) -> Bool) -> CollectionDifference<String.UnicodeScalarView.Element> where C : BidirectionalCollection, String.UnicodeScalarView.Element == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<String.UnicodeScalarView.Element> where C : BidirectionalCollection, String.UnicodeScalarView.Element == C.Element

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Substring.UnicodeScalarView> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (String.UnicodeScalarView.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: String.UnicodeScalarView.Element) -> String.UnicodeScalarView.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UnicodeScalarView where R : RangeExpression, String.UnicodeScalarView.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UnicodeScalarView { get }

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    @inlinable public init(repeating repeatedValue: String.UnicodeScalarView.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    @inlinable public init<S>(_ elements: S) where S : Sequence, String.UnicodeScalarView.Element == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many calls to `append(_:)` on the
    ///   same collection.
    @inlinable public mutating func append(_ newElement: String.UnicodeScalarView.Element)

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf newElements: S) where S : Sequence, String.UnicodeScalarView.Element == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection. If
    ///   `i == endIndex`, this method is equivalent to `append(_:)`.
    @inlinable public mutating func insert(_ newElement: String.UnicodeScalarView.Element, at i: String.UnicodeScalarView.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If `i == endIndex`, this method
    ///   is equivalent to `append(contentsOf:)`.
    @inlinable public mutating func insert<C>(contentsOf newElements: C, at i: String.UnicodeScalarView.Index) where C : Collection, String.UnicodeScalarView.Element == C.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   collection's end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func remove(at position: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Element

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange(_ bounds: Range<String.UnicodeScalarView.Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst() -> String.UnicodeScalarView.Element

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    @inlinable public mutating func reserveCapacity(_ n: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeFirst() -> String.UnicodeScalarView.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the specified
    ///   number of elements.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, the complexity
    ///   is O(*m*).
    @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, String.UnicodeScalarView.Element == C.Element, String.UnicodeScalarView.Index == R.Bound

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, String.UnicodeScalarView.Index == R.Bound

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> String.UnicodeScalarView.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> String.UnicodeScalarView.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Creates a new collection by concatenating the elements of a collection and
    /// a sequence.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of an integer array and a `Range<Int>` instance.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let moreNumbers = numbers + (5...10)
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: A collection or finite sequence.
    @inlinable public static func + <Other>(lhs: Substring.UnicodeScalarView, rhs: Other) -> Substring.UnicodeScalarView where Other : Sequence, String.UnicodeScalarView.Element == Other.Element

    /// Creates a new collection by concatenating the elements of a sequence and a
    /// collection.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of a `Range<Int>` instance and an integer array.
    ///
    ///     let numbers = [7, 8, 9, 10]
    ///     let moreNumbers = (1...6) + numbers
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of argument on the right-hand side.
    /// In the example above, `moreNumbers` has the same type as `numbers`, which
    /// is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A collection or finite sequence.
    ///   - rhs: A range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Other, rhs: Substring.UnicodeScalarView) -> Substring.UnicodeScalarView where Other : Sequence, String.UnicodeScalarView.Element == Other.Element

    /// Appends the elements of a sequence to a range-replaceable collection.
    ///
    /// Use this operator to append the elements of a sequence to the end of
    /// range-replaceable collection with same `Element` type. This example
    /// appends the elements of a `Range<Int>` instance to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers += 10...15
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameters:
    ///   - lhs: The array to append to.
    ///   - rhs: A collection or finite sequence.
    ///
    /// - Complexity: O(*m*), where *m* is the length of the right-hand-side
    ///   argument.
    @inlinable public static func += <Other>(lhs: inout Substring.UnicodeScalarView, rhs: Other) where Other : Sequence, String.UnicodeScalarView.Element == Other.Element

    /// Creates a new collection by concatenating the elements of two collections.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of two integer arrays.
    ///
    ///     let lowerNumbers = [1, 2, 3, 4]
    ///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
    ///     let allNumbers = lowerNumbers + higherNumbers
    ///     print(allNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: Another range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Substring.UnicodeScalarView, rhs: Other) -> Substring.UnicodeScalarView where Other : RangeReplaceableCollection, String.UnicodeScalarView.Element == Other.Element

    /// Returns a new collection of the same type containing, in order, the
    /// elements of the original collection that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned collection.
    /// - Returns: A collection of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @available(swift 4.0)
    @inlinable public func filter(_ isIncluded: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. The order of the remaining elements is preserved.
    /// This example removes all the vowels from a string:
    ///
    ///     var phrase = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     phrase.removeAll(where: { vowels.contains($0) })
    ///     // phrase == "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter shouldBeRemoved: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(where shouldBeRemoved: (String.UnicodeScalarView.Element) throws -> Bool) rethrows

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Substring.UnicodeScalarView>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (String.UnicodeScalarView.Element) throws -> T) rethrows -> [T]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (String.UnicodeScalarView.Element) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Element?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<String.UnicodeScalarView.Element>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Substring.UnicodeScalarView>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (String.UnicodeScalarView.Element, String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Element?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (String.UnicodeScalarView.Element, String.UnicodeScalarView.Element) throws -> Bool) rethrows -> String.UnicodeScalarView.Element?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> String.UnicodeScalarView.Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> String.UnicodeScalarView.Element?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (String.UnicodeScalarView.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, String.UnicodeScalarView.Element == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (String.UnicodeScalarView.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UnicodeScalarView.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (String.UnicodeScalarView.Element, String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, String.UnicodeScalarView.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, String.UnicodeScalarView.Element == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: String.UnicodeScalarView.Element) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, String.UnicodeScalarView.Element) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, String.UnicodeScalarView.Element) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (String.UnicodeScalarView.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (String.UnicodeScalarView.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [String.UnicodeScalarView.Element]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (String.UnicodeScalarView.Element, String.UnicodeScalarView.Element) throws -> Bool) rethrows -> [String.UnicodeScalarView.Element]

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, String.UnicodeScalarView.Element == Prefix.Element

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UnicodeScalarView where Prefix : Sequence, String.UnicodeScalarView.Element == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (String.UnicodeScalarView.Element) throws -> Bool) throws

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.UnicodeScalarView.Index>] where C : Collection, String.UnicodeScalarView.Element == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UnicodeScalarView.Index>? where C : Collection, String.UnicodeScalarView.Element == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.UnicodeScalarView.Index>? where C : Collection, String.UnicodeScalarView.Element == C.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `other`.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, subrange: Range<String.UnicodeScalarView.Index>, maxReplacements: Int = .max) -> Substring.UnicodeScalarView where C : Collection, Replacement : Collection, String.UnicodeScalarView.Element == C.Element, C.Element == Replacement.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) -> Substring.UnicodeScalarView where C : Collection, Replacement : Collection, String.UnicodeScalarView.Element == C.Element, C.Element == Replacement.Element

    /// Replaces all occurrences of a target sequence with a given collection
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) where C : Collection, Replacement : Collection, String.UnicodeScalarView.Element == C.Element, C.Element == Replacement.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (String.UnicodeScalarView.Element) throws -> Bool) rethrows

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, String.UnicodeScalarView.Element == Prefix.Element
}

/// Default implementation for forward collections.
extension Substring.UnicodeScalarView {

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UnicodeScalarView.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.UnicodeScalarView.Index, offsetBy distance: Int, limitedBy limit: String.UnicodeScalarView.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> String.UnicodeScalarView.Element? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> String.UnicodeScalarView.Element?
}

/// Ambiguity breakers.
extension Substring.UnicodeScalarView {

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> String.UnicodeScalarView.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> String.UnicodeScalarView.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)
}

/// Default implementations of core requirements
extension Substring.UnicodeScalarView {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: String.UnicodeScalarView.Element? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

extension Substring.UnicodeScalarView : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    @inlinable public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Substring.UnicodeScalarView.Index>, with replacement: C) where C : Collection, C.Element == Unicode.Scalar
}

extension Substring.UnicodeScalarView : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.UnicodeScalarView.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = String.UnicodeScalarView.Indices

    /// A type representing the sequence's elements.
    public typealias Element = String.UnicodeScalarView.Element

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UnicodeScalarView

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Substring.UnicodeScalarView.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Substring.UnicodeScalarView.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(index: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Element { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: Substring.UnicodeScalarView.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable public func index(after i: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Substring.UnicodeScalarView.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UnicodeScalarView.Index, offsetBy n: Int) -> Substring.UnicodeScalarView.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: Substring.UnicodeScalarView.Index, offsetBy n: Int, limitedBy limit: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @inlinable public func distance(from start: Substring.UnicodeScalarView.Index, to end: Substring.UnicodeScalarView.Index) -> Int

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before i: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Substring.UnicodeScalarView.Index)

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(r: Range<Substring.UnicodeScalarView.Index>) -> Substring.UnicodeScalarView { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Substring.UnicodeScalarView>
}

/// A type that can represent a string as a collection of characters.
///
/// Do not declare new conformances to `StringProtocol`. Only the `String` and
/// `Substring` types in the standard library are valid conforming types.
public protocol StringProtocol : BidirectionalCollection, Comparable, ExpressibleByStringInterpolation, Hashable, LosslessStringConvertible, TextOutputStream, TextOutputStreamable where Self.Element == Character, Self.Index == String.Index, Self.StringInterpolation == DefaultStringInterpolation, Self.SubSequence : StringProtocol {

    associatedtype UTF8View : Collection where Self.UTF8View.Element == UInt8, Self.UTF8View.Index == String.Index

    associatedtype UTF16View : BidirectionalCollection where Self.UTF16View.Element == UInt16, Self.UTF16View.Index == String.Index

    associatedtype UnicodeScalarView : BidirectionalCollection where Self.UnicodeScalarView.Element == Unicode.Scalar, Self.UnicodeScalarView.Index == String.Index

    associatedtype SubSequence = Substring

    var utf8: Self.UTF8View { get }

    var utf16: Self.UTF16View { get }

    var unicodeScalars: Self.UnicodeScalarView { get }

    func hasPrefix(_ prefix: String) -> Bool

    func hasSuffix(_ suffix: String) -> Bool

    func lowercased() -> String

    func uppercased() -> String

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a string from the null-terminated, UTF-8 encoded sequence of
    /// bytes at the given pointer.
    ///
    /// - Parameter nullTerminatedUTF8: A pointer to a sequence of contiguous,
    ///   UTF-8 encoded bytes ending just before the first zero byte.
    init(cString nullTerminatedUTF8: UnsafePointer<CChar>)

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : _UnicodeEncoding
}

extension StringProtocol {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    @inlinable public static func != <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func >= <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether the string begins with the
    /// specified prefix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let cafe = "Café du Monde"
    ///
    ///     // Case sensitive
    ///     print(cafe.hasPrefix("café"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode extended grapheme clusters
    /// rather than the code points used to compose them. The example below uses
    /// two strings with different forms of the `"é"` character---the first uses
    /// the composed form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "Café"
    ///     let decomposedCafe = "Cafe\u{0301}"
    ///
    ///     print(cafe.hasPrefix(composedCafe))
    ///     // Prints "true"
    ///     print(cafe.hasPrefix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter prefix: A possible prefix to test against this string.
    /// - Returns: `true` if the string begins with `prefix`; otherwise, `false`.
    @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where Prefix : StringProtocol

    /// Returns a Boolean value indicating whether the string ends with the
    /// specified suffix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let plans = "Let's meet at the café"
    ///
    ///     // Case sensitive
    ///     print(plans.hasSuffix("Café"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode extended grapheme clusters
    /// rather than the code points used to compose them. The example below uses
    /// two strings with different forms of the `"é"` character---the first uses
    /// the composed form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "café"
    ///     let decomposedCafe = "cafe\u{0301}"
    ///
    ///     print(plans.hasSuffix(composedCafe))
    ///     // Prints "true"
    ///     print(plans.hasSuffix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter suffix: A possible suffix to test against this string.
    /// - Returns: `true` if the string ends with `suffix`; otherwise, `false`.
    @inlinable public func hasSuffix<Suffix>(_ suffix: Suffix) -> Bool where Suffix : StringProtocol

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func contains(_ other: String) -> Bool

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func contains(_ other: Substring) -> Bool
}

/// A single extended grapheme cluster that approximates a user-perceived
/// character.
///
/// The `Character` type represents a character made up of one or more Unicode
/// scalar values, grouped by a Unicode boundary algorithm. Generally, a
/// `Character` instance matches what the reader of a string will perceive as
/// a single character. Strings are collections of `Character` instances, so
/// the number of visible characters is generally the most natural way to
/// count the length of a string.
///
///     let greeting = "Hello! 🐥"
///     print("Length: \(greeting.count)")
///     // Prints "Length: 8"
///
/// Because each character in a string can be made up of one or more Unicode
/// scalar values, the number of characters in a string may not match the
/// length of the Unicode scalar value representation or the length of the
/// string in a particular binary representation.
///
///     print("Unicode scalar value count: \(greeting.unicodeScalars.count)")
///     // Prints "Unicode scalar value count: 8"
///
///     print("UTF-8 representation count: \(greeting.utf8.count)")
///     // Prints "UTF-8 representation count: 11"
///
/// Every `Character` instance is composed of one or more Unicode scalar values
/// that are grouped together as an *extended grapheme cluster*. The way these
/// scalar values are grouped is defined by a canonical, localized, or
/// otherwise tailored Unicode segmentation algorithm.
///
/// For example, a country's Unicode flag character is made up of two regional
/// indicator scalar values that correspond to that country's ISO 3166-1
/// alpha-2 code. The alpha-2 code for The United States is "US", so its flag
/// character is made up of the Unicode scalar values `"\u{1F1FA}"` (REGIONAL
/// INDICATOR SYMBOL LETTER U) and `"\u{1F1F8}"` (REGIONAL INDICATOR SYMBOL
/// LETTER S). When placed next to each other in a string literal, these two
/// scalar values are combined into a single grapheme cluster, represented by
/// a `Character` instance in Swift.
///
///     let usFlag: Character = "\u{1F1FA}\u{1F1F8}"
///     print(usFlag)
///     // Prints "🇺🇸"
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters] and [Unicode scalar
/// values][scalars].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
@frozen public struct Character : Sendable {

    /// A view of a character's contents as a collection of UTF-8 code units. See
    /// String.UTF8View for more information
    public typealias UTF8View = String.UTF8View

    /// A UTF-8 encoding of `self`.
    @inlinable public var utf8: Character.UTF8View { get }

    /// A view of a character's contents as a collection of UTF-16 code units. See
    /// String.UTF16View for more information
    public typealias UTF16View = String.UTF16View

    /// A UTF-16 encoding of `self`.
    @inlinable public var utf16: Character.UTF16View { get }

    public typealias UnicodeScalarView = String.UnicodeScalarView

    @inlinable public var unicodeScalars: Character.UnicodeScalarView { get }

    /// A Boolean value indicating whether this is an ASCII character.
    @inlinable public var isASCII: Bool { get }

    /// The ASCII encoding value of this character, if it is an ASCII character.
    ///
    ///     let chars: [Character] = ["a", " ", "™"]
    ///     for ch in chars {
    ///         print(ch, "-->", ch.asciiValue)
    ///     }
    ///     // Prints:
    ///     // a --> Optional(97)
    ///     //   --> Optional(32)
    ///     // ™ --> nil
    ///
    /// A character with the value "\r\n" (CR-LF) is normalized to "\n" (LF) and
    /// has an `asciiValue` property equal to 10.
    ///
    ///     let cr = "\r" as Character
    ///     // cr.asciiValue == 13
    ///     let lf = "\n" as Character
    ///     // lf.asciiValue == 10
    ///     let crlf = "\r\n" as Character
    ///     // crlf.asciiValue == 10
    @inlinable public var asciiValue: UInt8? { get }

    /// A Boolean value indicating whether this character represents whitespace,
    /// including newlines.
    ///
    /// For example, the following characters all represent whitespace:
    ///
    /// - "\t" (U+0009 CHARACTER TABULATION)
    /// - " " (U+0020 SPACE)
    /// - U+2029 PARAGRAPH SEPARATOR
    /// - U+3000 IDEOGRAPHIC SPACE
    public var isWhitespace: Bool { get }

    /// A Boolean value indicating whether this character represents a newline.
    ///
    /// For example, the following characters all represent newlines:
    ///
    /// - "\n" (U+000A): LINE FEED (LF)
    /// - U+000B: LINE TABULATION (VT)
    /// - U+000C: FORM FEED (FF)
    /// - "\r" (U+000D): CARRIAGE RETURN (CR)
    /// - "\r\n" (U+000D U+000A): CR-LF
    /// - U+0085: NEXT LINE (NEL)
    /// - U+2028: LINE SEPARATOR
    /// - U+2029: PARAGRAPH SEPARATOR
    @inlinable public var isNewline: Bool { get }

    /// A Boolean value indicating whether this character represents a number.
    ///
    /// For example, the following characters all represent numbers:
    ///
    /// - "7" (U+0037 DIGIT SEVEN)
    /// - "⅚" (U+215A VULGAR FRACTION FIVE SIXTHS)
    /// - "㊈" (U+3288 CIRCLED IDEOGRAPH NINE)
    /// - "𝟠" (U+1D7E0 MATHEMATICAL DOUBLE-STRUCK DIGIT EIGHT)
    /// - "๒" (U+0E52 THAI DIGIT TWO)
    public var isNumber: Bool { get }

    /// A Boolean value indicating whether this character represents a whole
    /// number.
    ///
    /// For example, the following characters all represent whole numbers:
    ///
    /// - "1" (U+0031 DIGIT ONE) => 1
    /// - "५" (U+096B DEVANAGARI DIGIT FIVE) => 5
    /// - "๙" (U+0E59 THAI DIGIT NINE) => 9
    /// - "万" (U+4E07 CJK UNIFIED IDEOGRAPH-4E07) => 10_000
    @inlinable public var isWholeNumber: Bool { get }

    /// The numeric value this character represents, if it represents a whole
    /// number.
    ///
    /// If this character does not represent a whole number, or the value is too
    /// large to represent as an `Int`, the value of this property is `nil`.
    ///
    ///     let chars: [Character] = ["4", "④", "万", "a"]
    ///     for ch in chars {
    ///         print(ch, "-->", ch.wholeNumberValue)
    ///     }
    ///     // Prints:
    ///     // 4 --> Optional(4)
    ///     // ④ --> Optional(4)
    ///     // 万 --> Optional(10000)
    ///     // a --> nil
    public var wholeNumberValue: Int? { get }

    /// A Boolean value indicating whether this character represents a
    /// hexadecimal digit.
    ///
    /// Hexadecimal digits include 0-9, Latin letters a-f and A-F, and their
    /// fullwidth compatibility forms. To get the character's value, use the
    /// `hexDigitValue` property.
    @inlinable public var isHexDigit: Bool { get }

    /// The numeric value this character represents, if it is a hexadecimal digit.
    ///
    /// Hexadecimal digits include 0-9, Latin letters a-f and A-F, and their
    /// fullwidth compatibility forms. If the character does not represent a
    /// hexadecimal digit, the value of this property is `nil`.
    ///
    ///     let chars: [Character] = ["1", "a", "Ｆ", "g"]
    ///     for ch in chars {
    ///         print(ch, "-->", ch.hexDigitValue)
    ///     }
    ///     // Prints:
    ///     // 1 --> Optional(1)
    ///     // a --> Optional(10)
    ///     // Ｆ --> Optional(15)
    ///     // g --> nil
    public var hexDigitValue: Int? { get }

    /// A Boolean value indicating whether this character is a letter.
    ///
    /// For example, the following characters are all letters:
    ///
    /// - "A" (U+0041 LATIN CAPITAL LETTER A)
    /// - "é" (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT)
    /// - "ϴ" (U+03F4 GREEK CAPITAL THETA SYMBOL)
    /// - "ڈ" (U+0688 ARABIC LETTER DDAL)
    /// - "日" (U+65E5 CJK UNIFIED IDEOGRAPH-65E5)
    /// - "ᚨ" (U+16A8 RUNIC LETTER ANSUZ A)
    public var isLetter: Bool { get }

    /// Returns an uppercased version of this character.
    ///
    /// Because case conversion can result in multiple characters, the result
    /// of `uppercased()` is a string.
    ///
    ///     let chars: [Character] = ["e", "é", "и", "π", "ß", "1"]
    ///     for ch in chars {
    ///         print(ch, "-->", ch.uppercased())
    ///     }
    ///     // Prints:
    ///     // e --> E
    ///     // é --> É
    ///     // и --> И
    ///     // π --> Π
    ///     // ß --> SS
    ///     // 1 --> 1
    public func uppercased() -> String

    /// Returns a lowercased version of this character.
    ///
    /// Because case conversion can result in multiple characters, the result
    /// of `lowercased()` is a string.
    ///
    ///     let chars: [Character] = ["E", "É", "И", "Π", "1"]
    ///     for ch in chars {
    ///         print(ch, "-->", ch.lowercased())
    ///     }
    ///     // Prints:
    ///     // E --> e
    ///     // É --> é
    ///     // И --> и
    ///     // Π --> π
    ///     // 1 --> 1
    public func lowercased() -> String

    /// A Boolean value indicating whether this character is considered uppercase.
    ///
    /// Uppercase characters vary under case-conversion to lowercase, but not when
    /// converted to uppercase. The following characters are all uppercase:
    ///
    /// - "É" (U+0045 LATIN CAPITAL LETTER E, U+0301 COMBINING ACUTE ACCENT)
    /// - "И" (U+0418 CYRILLIC CAPITAL LETTER I)
    /// - "Π" (U+03A0 GREEK CAPITAL LETTER PI)
    @inlinable public var isUppercase: Bool { get }

    /// A Boolean value indicating whether this character is considered lowercase.
    ///
    /// Lowercase characters change when converted to uppercase, but not when
    /// converted to lowercase. The following characters are all lowercase:
    ///
    /// - "é" (U+0065 LATIN SMALL LETTER E, U+0301 COMBINING ACUTE ACCENT)
    /// - "и" (U+0438 CYRILLIC SMALL LETTER I)
    /// - "π" (U+03C0 GREEK SMALL LETTER PI)
    @inlinable public var isLowercase: Bool { get }

    /// A Boolean value indicating whether this character changes under any form
    /// of case conversion.
    @inlinable public var isCased: Bool { get }

    /// A Boolean value indicating whether this character represents a symbol.
    ///
    /// This property is `true` only for characters composed of scalars in the
    /// "Math_Symbol", "Currency_Symbol", "Modifier_Symbol", or "Other_Symbol"
    /// categories in the
    /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
    ///
    /// For example, the following characters all represent symbols:
    ///
    /// - "®" (U+00AE REGISTERED SIGN)
    /// - "⌹" (U+2339 APL FUNCTIONAL SYMBOL QUAD DIVIDE)
    /// - "⡆" (U+2846 BRAILLE PATTERN DOTS-237)
    public var isSymbol: Bool { get }

    /// A Boolean value indicating whether this character represents a symbol
    /// that naturally appears in mathematical contexts.
    ///
    /// For example, the following characters all represent math symbols:
    ///
    /// - "+" (U+002B PLUS SIGN)
    /// - "∫" (U+222B INTEGRAL)
    /// - "ϰ" (U+03F0 GREEK KAPPA SYMBOL)
    ///
    /// The set of characters that have an `isMathSymbol` value of `true` is not
    /// a strict subset of those for which `isSymbol` is `true`. This includes
    /// characters used both as letters and commonly in mathematical formulas.
    /// For example, "ϰ" (U+03F0 GREEK KAPPA SYMBOL) is considered both a
    /// mathematical symbol and a letter.
    ///
    /// This property corresponds to the "Math" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isMathSymbol: Bool { get }

    /// A Boolean value indicating whether this character represents a currency
    /// symbol.
    ///
    /// For example, the following characters all represent currency symbols:
    ///
    /// - "$" (U+0024 DOLLAR SIGN)
    /// - "¥" (U+00A5 YEN SIGN)
    /// - "€" (U+20AC EURO SIGN)
    public var isCurrencySymbol: Bool { get }

    /// A Boolean value indicating whether this character represents punctuation.
    ///
    /// For example, the following characters all represent punctuation:
    ///
    /// - "!" (U+0021 EXCLAMATION MARK)
    /// - "؟" (U+061F ARABIC QUESTION MARK)
    /// - "…" (U+2026 HORIZONTAL ELLIPSIS)
    /// - "—" (U+2014 EM DASH)
    /// - "“" (U+201C LEFT DOUBLE QUOTATION MARK)
    public var isPunctuation: Bool { get }

    /// A custom playground Quick Look for the `Character` instance.
    @available(*, deprecated, message: "Character.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: Character, maximum: Character) -> ClosedRange<Character>

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: Character, rhs: Character) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: Character, rhs: Character) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: Character, rhs: Character) -> Bool

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: Character)

    public static func != (lhs: Character, rhs: Character) -> Bool

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: Character, maximum: Character) -> Range<Character>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: Character) -> PartialRangeUpTo<Character>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: Character) -> PartialRangeThrough<Character>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: Character) -> PartialRangeFrom<Character>
}

extension Character : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates a character containing the given Unicode scalar value.
    ///
    /// - Parameter content: The Unicode scalar value to convert into a character.
    @inlinable public init(_ content: Unicode.Scalar)

    /// Creates a character with the specified value.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use a string literal to initialize a `Character` instance. For
    /// example:
    ///
    ///     let oBreve: Character = "o\u{306}"
    ///     print(oBreve)
    ///     // Prints "ŏ"
    ///
    /// The assignment to the `oBreve` constant calls this initializer behind the
    /// scenes.
    @inlinable public init(extendedGraphemeClusterLiteral value: Character)

    /// Creates a character from a single-character string.
    ///
    /// The following example creates a new character from the uppercase version
    /// of a string that only holds one character.
    ///
    ///     let a = "a"
    ///     let capitalA = Character(a.uppercased())
    ///
    /// - Parameter s: The single-character string to convert to a `Character`
    ///   instance. `s` must contain exactly one extended grapheme cluster.
    @inlinable public init(_ s: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = Character

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = Character
}

extension Character : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

extension Character : CustomDebugStringConvertible {

    /// A textual representation of the character, suitable for debugging.
    public var debugDescription: String { get }
}

extension Character : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: Character, rhs: Character) -> Bool
}

extension Character : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < (lhs: Character, rhs: Character) -> Bool
}

extension Character : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

extension Character : CustomReflectable {

    /// A mirror that reflects the `Character` instance.
    public var customMirror: Mirror { get }
}

extension Character : TextOutputStreamable {

    /// Writes the character into the given output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

/// A Unicode string value that is a collection of characters.
///
/// A string is a series of characters, such as `"Swift"`, that forms a
/// collection. Strings in Swift are Unicode correct and locale insensitive,
/// and are designed to be efficient. The `String` type bridges with the
/// Objective-C class `NSString` and offers interoperability with C functions
/// that works with strings.
///
/// You can create new strings using string literals or string interpolations.
/// A *string literal* is a series of characters enclosed in quotes.
///
///     let greeting = "Welcome!"
///
/// *String interpolations* are string literals that evaluate any included
/// expressions and convert the results to string form. String interpolations
/// give you an easy way to build a string from multiple pieces. Wrap each
/// expression in a string interpolation in parentheses, prefixed by a
/// backslash.
///
///     let name = "Rosa"
///     let personalizedGreeting = "Welcome, \(name)!"
///     // personalizedGreeting == "Welcome, Rosa!"
///
///     let price = 2
///     let number = 3
///     let cookiePrice = "\(number) cookies: $\(price * number)."
///     // cookiePrice == "3 cookies: $6."
///
/// Combine strings using the concatenation operator (`+`).
///
///     let longerGreeting = greeting + " We're glad you're here!"
///     // longerGreeting == "Welcome! We're glad you're here!"
///
/// Multiline string literals are enclosed in three double quotation marks
/// (`"""`), with each delimiter on its own line. Indentation is stripped from
/// each line of a multiline string literal to match the indentation of the
/// closing delimiter.
///
///     let banner = """
///               __,
///              (           o  /) _/_
///               `.  , , , ,  //  /
///             (___)(_(_/_(_ //_ (__
///                          /)
///                         (/
///             """
///
/// Modifying and Comparing Strings
/// ===============================
///
/// Strings always have value semantics. Modifying a copy of a string leaves
/// the original unaffected.
///
///     var otherGreeting = greeting
///     otherGreeting += " Have a nice time!"
///     // otherGreeting == "Welcome! Have a nice time!"
///
///     print(greeting)
///     // Prints "Welcome!"
///
/// Comparing strings for equality using the equal-to operator (`==`) or a
/// relational operator (like `<` or `>=`) is always performed using Unicode
/// canonical representation. As a result, different representations of a
/// string compare as being equal.
///
///     let cafe1 = "Cafe\u{301}"
///     let cafe2 = "Café"
///     print(cafe1 == cafe2)
///     // Prints "true"
///
/// The Unicode scalar value `"\u{301}"` modifies the preceding character to
/// include an accent, so `"e\u{301}"` has the same canonical representation
/// as the single Unicode scalar value `"é"`.
///
/// Basic string operations are not sensitive to locale settings, ensuring that
/// string comparisons and other operations always have a single, stable
/// result, allowing strings to be used as keys in `Dictionary` instances and
/// for other purposes.
///
/// Accessing String Elements
/// =========================
///
/// A string is a collection of *extended grapheme clusters*, which approximate
/// human-readable characters. Many individual characters, such as "é", "김",
/// and "🇮🇳", can be made up of multiple Unicode scalar values. These scalar
/// values are combined by Unicode's boundary algorithms into extended
/// grapheme clusters, represented by the Swift `Character` type. Each element
/// of a string is represented by a `Character` instance.
///
/// For example, to retrieve the first word of a longer string, you can search
/// for a space and then create a substring from a prefix of the string up to
/// that point:
///
///     let name = "Marie Curie"
///     let firstSpace = name.firstIndex(of: " ") ?? name.endIndex
///     let firstName = name[..<firstSpace]
///     // firstName == "Marie"
///
/// The `firstName` constant is an instance of the `Substring` type---a type
/// that represents substrings of a string while sharing the original string's
/// storage. Substrings present the same interface as strings.
///
///     print("\(name)'s first name has \(firstName.count) letters.")
///     // Prints "Marie Curie's first name has 5 letters."
///
/// Accessing a String's Unicode Representation
/// ===========================================
///
/// If you need to access the contents of a string as encoded in different
/// Unicode encodings, use one of the string's `unicodeScalars`, `utf16`, or
/// `utf8` properties. Each property provides access to a view of the string
/// as a series of code units, each encoded in a different Unicode encoding.
///
/// To demonstrate the different views available for every string, the
/// following examples use this `String` instance:
///
///     let cafe = "Cafe\u{301} du 🌍"
///     print(cafe)
///     // Prints "Café du 🌍"
///
/// The `cafe` string is a collection of the nine characters that are visible
/// when the string is displayed.
///
///     print(cafe.count)
///     // Prints "9"
///     print(Array(cafe))
///     // Prints "["C", "a", "f", "é", " ", "d", "u", " ", "🌍"]"
///
/// Unicode Scalar View
/// -------------------
///
/// A string's `unicodeScalars` property is a collection of Unicode scalar
/// values, the 21-bit codes that are the basic unit of Unicode. Each scalar
/// value is represented by a `Unicode.Scalar` instance and is equivalent to a
/// UTF-32 code unit.
///
///     print(cafe.unicodeScalars.count)
///     // Prints "10"
///     print(Array(cafe.unicodeScalars))
///     // Prints "["C", "a", "f", "e", "\u{0301}", " ", "d", "u", " ", "\u{0001F30D}"]"
///     print(cafe.unicodeScalars.map { $0.value })
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]"
///
/// The `unicodeScalars` view's elements comprise each Unicode scalar value in
/// the `cafe` string. In particular, because `cafe` was declared using the
/// decomposed form of the `"é"` character, `unicodeScalars` contains the
/// scalar values for both the letter `"e"` (101) and the accent character
/// `"´"` (769).
///
/// UTF-16 View
/// -----------
///
/// A string's `utf16` property is a collection of UTF-16 code units, the
/// 16-bit encoding form of the string's Unicode scalar values. Each code unit
/// is stored as a `UInt16` instance.
///
///     print(cafe.utf16.count)
///     // Prints "11"
///     print(Array(cafe.utf16))
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]"
///
/// The elements of the `utf16` view are the code units for the string when
/// encoded in UTF-16. These elements match those accessed through indexed
/// `NSString` APIs.
///
///     let nscafe = cafe as NSString
///     print(nscafe.length)
///     // Prints "11"
///     print(nscafe.character(at: 3))
///     // Prints "101"
///
/// UTF-8 View
/// ----------
///
/// A string's `utf8` property is a collection of UTF-8 code units, the 8-bit
/// encoding form of the string's Unicode scalar values. Each code unit is
/// stored as a `UInt8` instance.
///
///     print(cafe.utf8.count)
///     // Prints "14"
///     print(Array(cafe.utf8))
///     // Prints "[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]"
///
/// The elements of the `utf8` view are the code units for the string when
/// encoded in UTF-8. This representation matches the one used when `String`
/// instances are passed to C APIs.
///
///     let cLength = strlen(cafe)
///     print(cLength)
///     // Prints "14"
///
/// Measuring the Length of a String
/// ================================
///
/// When you need to know the length of a string, you must first consider what
/// you'll use the length for. Are you measuring the number of characters that
/// will be displayed on the screen, or are you measuring the amount of
/// storage needed for the string in a particular encoding? A single string
/// can have greatly differing lengths when measured by its different views.
///
/// For example, an ASCII character like the capital letter *A* is represented
/// by a single element in each of its four views. The Unicode scalar value of
/// *A* is `65`, which is small enough to fit in a single code unit in both
/// UTF-16 and UTF-8.
///
///     let capitalA = "A"
///     print(capitalA.count)
///     // Prints "1"
///     print(capitalA.unicodeScalars.count)
///     // Prints "1"
///     print(capitalA.utf16.count)
///     // Prints "1"
///     print(capitalA.utf8.count)
///     // Prints "1"
///
/// On the other hand, an emoji flag character is constructed from a pair of
/// Unicode scalar values, like `"\u{1F1F5}"` and `"\u{1F1F7}"`. Each of these
/// scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8
/// code unit. As a result, each view of the string `"🇵🇷"` reports a different
/// length.
///
///     let flag = "🇵🇷"
///     print(flag.count)
///     // Prints "1"
///     print(flag.unicodeScalars.count)
///     // Prints "2"
///     print(flag.utf16.count)
///     // Prints "4"
///     print(flag.utf8.count)
///     // Prints "8"
///
/// To check whether a string is empty, use its `isEmpty` property instead of
/// comparing the length of one of the views to `0`. Unlike with `isEmpty`,
/// calculating a view's `count` property requires iterating through the
/// elements of the string.
///
/// Accessing String View Elements
/// ==============================
///
/// To find individual elements of a string, use the appropriate view for your
/// task. For example, to retrieve the first word of a longer string, you can
/// search the string for a space and then create a new string from a prefix
/// of the string up to that point.
///
///     let name = "Marie Curie"
///     let firstSpace = name.firstIndex(of: " ") ?? name.endIndex
///     let firstName = name[..<firstSpace]
///     print(firstName)
///     // Prints "Marie"
///
/// Strings and their views share indices, so you can access the UTF-8 view of
/// the `name` string using the same `firstSpace` index.
///
///     print(Array(name.utf8[..<firstSpace]))
///     // Prints "[77, 97, 114, 105, 101]"
///
/// Note that an index into one view may not have an exact corresponding
/// position in another view. For example, the `flag` string declared above
/// comprises a single character, but is composed of eight code units when
/// encoded as UTF-8. The following code creates constants for the first and
/// second positions in the `flag.utf8` view. Accessing the `utf8` view with
/// these indices yields the first and second code UTF-8 units.
///
///     let firstCodeUnit = flag.startIndex
///     let secondCodeUnit = flag.utf8.index(after: firstCodeUnit)
///     // flag.utf8[firstCodeUnit] == 240
///     // flag.utf8[secondCodeUnit] == 159
///
/// When used to access the elements of the `flag` string itself, however, the
/// `secondCodeUnit` index does not correspond to the position of a specific
/// character. Instead of only accessing the specific UTF-8 code unit, that
/// index is treated as the position of the character at the index's encoded
/// offset. In the case of `secondCodeUnit`, that character is still the flag
/// itself.
///
///     // flag[firstCodeUnit] == "🇵🇷"
///     // flag[secondCodeUnit] == "🇵🇷"
///
/// If you need to validate that an index from one string's view corresponds
/// with an exact position in another view, use the index's
/// `samePosition(in:)` method or the `init(_:within:)` initializer.
///
///     if let exactIndex = secondCodeUnit.samePosition(in: flag) {
///         print(flag[exactIndex])
///     } else {
///         print("No exact match for this position.")
///     }
///     // Prints "No exact match for this position."
///
/// Performance Optimizations
/// =========================
///
/// Although strings in Swift have value semantics, strings use a copy-on-write
/// strategy to store their data in a buffer. This buffer can then be shared
/// by different copies of a string. A string's data is only copied lazily,
/// upon mutation, when more than one string instance is using the same
/// buffer. Therefore, the first in any sequence of mutating operations may
/// cost O(*n*) time and space.
///
/// When a string's contiguous storage fills up, a new buffer must be allocated
/// and data must be moved to the new storage. String buffers use an
/// exponential growth strategy that makes appending to a string a constant
/// time operation when averaged over many append operations.
///
/// Bridging Between String and NSString
/// ====================================
///
/// Any `String` instance can be bridged to `NSString` using the type-cast
/// operator (`as`), and any `String` instance that originates in Objective-C
/// may use an `NSString` instance as its storage. Because any arbitrary
/// subclass of `NSString` can become a `String` instance, there are no
/// guarantees about representation or efficiency when a `String` instance is
/// backed by `NSString` storage. Because `NSString` is immutable, it is just
/// as though the storage was shared by a copy. The first in any sequence of
/// mutating operations causes elements to be copied into unique, contiguous
/// storage which may cost O(*n*) time and space, where *n* is the length of
/// the string's encoded representation (or more, if the underlying `NSString`
/// has unusual performance characteristics).
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters], [Unicode scalar
/// values][scalars], and [canonical equivalence][equivalence].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
/// [equivalence]: http://www.unicode.org/glossary/#canonical_equivalent
@frozen public struct String {

    /// Creates an empty string.
    ///
    /// Using this initializer is equivalent to initializing a string with an
    /// empty string literal.
    ///
    ///     let empty = ""
    ///     let alsoEmpty = String()
    @inlinable public init()

    /// Creates a new string by copying the null-terminated UTF-8 data referenced
    /// by the given pointer.
    ///
    /// If `cString` contains ill-formed UTF-8 code unit sequences, this
    /// initializer replaces them with the Unicode replacement character
    /// (`"\u{FFFD}"`).
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Café"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Caf�"
    ///
    /// - Parameter nullTerminatedUTF8: A pointer to a null-terminated UTF-8 code sequence.
    public init(cString nullTerminatedUTF8: UnsafePointer<CChar>)

    @inlinable public init(cString nullTerminatedUTF8: [CChar])

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    @inlinable public init(cString nullTerminatedUTF8: inout CChar)

    /// Creates a new string by copying the null-terminated UTF-8 data referenced
    /// by the given pointer.
    ///
    /// This is identical to `init(cString: UnsafePointer<CChar>)` but operates on
    /// an unsigned sequence of bytes.
    public init(cString nullTerminatedUTF8: UnsafePointer<UInt8>)

    @inlinable public init(cString nullTerminatedUTF8: [UInt8])

    @available(*, deprecated, message: "Use a copy of the String argument")
    @inlinable public init(cString nullTerminatedUTF8: String)

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    @inlinable public init(cString nullTerminatedUTF8: inout UInt8)

    /// Creates a new string by copying and validating the null-terminated UTF-8
    /// data referenced by the given pointer.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Optional("Café")"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "nil"
    ///
    /// - Parameter cString: A pointer to a null-terminated UTF-8 code sequence.
    public init?(validatingUTF8 cString: UnsafePointer<CChar>)

    @inlinable public init?(validatingUTF8 cString: [CChar])

    @available(*, deprecated, message: "Use a copy of the String argument")
    @inlinable public init?(validatingUTF8 cString: String)

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    @inlinable public init?(validatingUTF8 cString: inout CChar)

    /// Creates a new string by copying the null-terminated data referenced by
    /// the given pointer using the specified encoding.
    ///
    /// When you pass `true` as `isRepairing`, this method replaces ill-formed
    /// sequences with the Unicode replacement character (`"\u{FFFD}"`);
    /// otherwise, an ill-formed sequence causes this method to stop decoding
    /// and return `nil`.
    ///
    /// The following example calls this method with pointers to the contents of
    /// two different `CChar` arrays---the first with well-formed UTF-8 code
    /// unit sequences and the second with an ill-formed sequence at the end.
    ///
    ///     let validUTF8: [UInt8] = [67, 97, 102, 195, 169, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((result: "Café", repairsMade: false))"
    ///
    ///     let invalidUTF8: [UInt8] = [67, 97, 102, 195, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((result: "Caf�", repairsMade: true))"
    ///
    /// - Parameters:
    ///   - cString: A pointer to a null-terminated code sequence encoded in
    ///     `encoding`.
    ///   - encoding: The Unicode encoding of the data referenced by `cString`.
    ///   - isRepairing: Pass `true` to create a new string, even when the data
    ///     referenced by `cString` contains ill-formed sequences. Ill-formed
    ///     sequences are replaced with the Unicode replacement character
    ///     (`"\u{FFFD}"`). Pass `false` to interrupt the creation of the new
    ///     string if an ill-formed sequence is detected.
    /// - Returns: A tuple with the new string and a Boolean value that indicates
    ///   whether any repairs were made. If `isRepairing` is `false` and an
    ///   ill-formed sequence is detected, this method returns `nil`.
    @inlinable public static func decodeCString<Encoding>(_ cString: UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = true) -> (result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding

    @inlinable public static func decodeCString<Encoding>(_ cString: [Encoding.CodeUnit], as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = true) -> (result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding

    @available(*, deprecated, message: "Use a copy of the String argument")
    @inlinable public static func decodeCString<Encoding>(_ cString: String, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = true) -> (result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    @inlinable public static func decodeCString<Encoding>(_ cString: inout Encoding.CodeUnit, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = true) -> (result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: [Encoding.CodeUnit], as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    @available(*, deprecated, message: "Use a copy of the String argument")
    @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: String, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: inout Encoding.CodeUnit, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Creates a string containing the given character.
    ///
    /// - Parameter c: The character to convert to a string.
    @inlinable public init(_ c: Character)

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    @inlinable public func withCString<Result>(_ body: (UnsafePointer<Int8>) throws -> Result) rethrows -> Result

    /// A type that represents the number of steps between two `String.Index`
    /// values, where one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    @available(*, deprecated, message: "All index distances are now of type Int")
    public typealias IndexDistance = Int

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `instance.write(to: s)` on an empty
    ///   string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(describing: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(describing: p))
    ///     // Prints "(21, 30)"
    public init<Subject>(describing instance: Subject)

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `instance.write(to: s)` on an empty
    ///   string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(describing: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(describing: p))
    ///     // Prints "(21, 30)"
    @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `instance.write(to: s)` on an empty
    ///   string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(describing: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(describing: p))
    ///     // Prints "(21, 30)"
    @inlinable public init<Subject>(describing instance: Subject) where Subject : TextOutputStreamable

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `instance.write(to: s)` on an empty
    ///   string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(describing: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(describing: p))
    ///     // Prints "(21, 30)"
    @inlinable public init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible, Subject : TextOutputStreamable

    /// Creates a string with a detailed representation of the given value,
    /// suitable for debugging.
    ///
    /// Use this initializer to convert an instance of any type to its custom
    /// debugging representation. The initializer creates the string
    /// representation of `instance` in one of the following ways, depending on
    /// its protocol conformance:
    ///
    /// - If `subject` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `subject.debugDescription`.
    /// - If `subject` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `subject.description`.
    /// - If `subject` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `subject.write(to: s)` on an empty
    ///   string `s`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(reflecting: p))
    ///     // Prints "p: Point = {
    ///     //           x = 21
    ///     //           y = 30
    ///     //         }"
    ///
    /// After adding `CustomDebugStringConvertible` conformance by implementing
    /// the `debugDescription` property, `Point` provides its own custom
    /// debugging representation.
    ///
    ///     extension Point: CustomDebugStringConvertible {
    ///         var debugDescription: String {
    ///             return "Point(x: \(x), y: \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(reflecting: p))
    ///     // Prints "Point(x: 21, y: 30)"
    public init<Subject>(reflecting subject: Subject)

    /// A custom playground Quick Look for the `String` instance.
    @available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    @inlinable public init(_ scalar: Unicode.Scalar)

    @inlinable public static func + (lhs: String, rhs: String) -> String

    @inlinable public static func += (lhs: inout String, rhs: String)

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @frozen public struct Iterator : IteratorProtocol, Sendable {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> Character?

        /// The type of element traversed by the iterator.
        public typealias Element = Character
    }

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> String.Iterator

    public static func ~= (lhs: String, rhs: Substring) -> Bool

    /// A position of a character or code unit in a string.
    @frozen public struct Index : Sendable {
    }

    /// Creates a new instance from an interpolated string literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public init(stringInterpolation: DefaultStringInterpolation)

    /// Creates a new string representing the given string repeated the specified
    /// number of times.
    ///
    /// For example, you can use this initializer to create a string with ten
    /// `"ab"` strings in a row.
    ///
    ///     let s = String(repeating: "ab", count: 10)
    ///     print(s)
    ///     // Prints "abababababababababab"
    ///
    /// - Parameters:
    ///   - repeatedValue: The string to repeat.
    ///   - count: The number of times to repeat `repeatedValue` in the resulting
    ///     string.
    public init(repeating repeatedValue: String, count: Int)

    /// A Boolean value indicating whether a string has no characters.
    @inlinable public var isEmpty: Bool { get }

    public func hasPrefix(_ prefix: String) -> Bool

    public func hasSuffix(_ suffix: String) -> Bool

    /// Creates a string representing the given value in base 10, or some other
    /// specified base.
    ///
    /// The following example converts the maximal `Int` value to a string and
    /// prints its length:
    ///
    ///     let max = String(Int.max)
    ///     print("\(max) has \(max.count) digits.")
    ///     // Prints "9223372036854775807 has 19 digits."
    ///
    /// Numerals greater than 9 are represented as Roman letters. These letters
    /// start with `"A"` if `uppercase` is `true`; otherwise, with `"a"`.
    ///
    ///     let v = 999_999
    ///     print(String(v, radix: 2))
    ///     // Prints "11110100001000111111"
    ///
    ///     print(String(v, radix: 16))
    ///     // Prints "f423f"
    ///     print(String(v, radix: 16, uppercase: true))
    ///     // Prints "F423F"
    ///
    /// - Parameters:
    ///   - value: The value to convert to a string.
    ///   - radix: The base to use for the string representation. `radix` must be
    ///     at least 2 and at most 36. The default is 10.
    ///   - uppercase: Pass `true` to use uppercase letters to represent numerals
    ///     greater than 9, or `false` to use lowercase letters. The default is
    ///     `false`.
    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger

    /// Returns whether this string is capable of providing access to
    /// validly-encoded UTF-8 contents in contiguous memory in O(1) time.
    ///
    /// Contiguous strings always operate in O(1) time for withUTF8 and always
    /// give a result for String.UTF8View.withContiguousStorageIfAvailable.
    /// Contiguous strings also benefit from fast-paths and better optimizations.
    ///
    public var isContiguousUTF8: Bool { get }

    /// If this string is not contiguous, make it so. If this mutates the string,
    /// it will invalidate any pre-existing indices.
    ///
    /// Complexity: O(n) if non-contiguous, O(1) if already contiguous
    ///
    public mutating func makeContiguousUTF8()

    /// Runs `body` over the content of this string in contiguous memory. If this
    /// string is not contiguous, this will first make it contiguous, which will
    /// also speed up subsequent access. If this mutates the string,
    /// it will invalidate any pre-existing indices.
    ///
    /// Note that it is unsafe to escape the pointer provided to `body`. For
    /// example, strings of up to 15 UTF-8 code units in length may be represented
    /// in a small-string representation, and thus will be spilled into
    /// temporary stack space which is invalid after `withUTF8` finishes
    /// execution.
    ///
    /// Complexity: O(n) if non-contiguous, O(1) if already contiguous
    ///
    public mutating func withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R

    public func max<T>(_ x: T, _ y: T) -> T where T : Comparable

    public func min<T>(_ x: T, _ y: T) -> T where T : Comparable

    /// A view of a string's contents as a collection of UTF-16 code units.
    ///
    /// You can access a string's view of UTF-16 code units by using its `utf16`
    /// property. A string's UTF-16 view encodes the string's Unicode scalar
    /// values as 16-bit integers.
    ///
    ///     let flowers = "Flowers 💐"
    ///     for v in flowers.utf16 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 55357
    ///     // 56464
    ///
    /// Unicode scalar values that make up a string's contents can be up to 21
    /// bits long. The longer scalar values may need two `UInt16` values for
    /// storage. Those "pairs" of code units are called *surrogate pairs*.
    ///
    ///     let flowermoji = "💐"
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     // 💐 128144
    ///
    ///     for v in flowermoji.utf16 {
    ///         print(v)
    ///     }
    ///     // 55357
    ///     // 56464
    ///
    /// To convert a `String.UTF16View` instance back into a string, use the
    /// `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is 🎉"
    ///     if let i = favemoji.utf16.firstIndex(where: { $0 >= 128 }) {
    ///         let asciiPrefix = String(favemoji.utf16[..<i])!
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    ///
    /// UTF16View Elements Match NSString Characters
    /// ============================================
    ///
    /// The UTF-16 code units of a string's `utf16` view match the elements
    /// accessed through indexed `NSString` APIs.
    ///
    ///     print(flowers.utf16.count)
    ///     // Prints "10"
    ///
    ///     let nsflowers = flowers as NSString
    ///     print(nsflowers.length)
    ///     // Prints "10"
    ///
    /// Unlike `NSString`, however, `String.UTF16View` does not use integer
    /// indices. If you need to access a specific position in a UTF-16 view, use
    /// Swift's index manipulation methods. The following example accesses the
    /// fourth code unit in both the `flowers` and `nsflowers` strings:
    ///
    ///     print(nsflowers.character(at: 3))
    ///     // Prints "119"
    ///
    ///     let i = flowers.utf16.index(flowers.utf16.startIndex, offsetBy: 3)
    ///     print(flowers.utf16[i])
    ///     // Prints "119"
    ///
    /// Although the Swift overlay updates many Objective-C methods to return
    /// native Swift indices and index ranges, some still return instances of
    /// `NSRange`. To convert an `NSRange` instance to a range of
    /// `String.Index`, use the `Range(_:in:)` initializer, which takes an
    /// `NSRange` and a string as arguments.
    ///
    ///     let snowy = "❄️ Let it snow! ☃️"
    ///     let nsrange = NSRange(location: 3, length: 12)
    ///     if let range = Range(nsrange, in: snowy) {
    ///         print(snowy[range])
    ///     }
    ///     // Prints "Let it snow!"
    @frozen public struct UTF16View : Sendable {
    }

    /// A UTF-16 encoding of `self`.
    @inlinable public var utf16: String.UTF16View

    /// Creates a string corresponding to the given sequence of UTF-16 code units.
    @available(swift 4.0)
    @inlinable public init(_ utf16: String.UTF16View)

    /// A view of a string's contents as a collection of UTF-8 code units.
    ///
    /// You can access a string's view of UTF-8 code units by using its `utf8`
    /// property. A string's UTF-8 view encodes the string's Unicode scalar
    /// values as 8-bit integers.
    ///
    ///     let flowers = "Flowers 💐"
    ///     for v in flowers.utf8 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// A string's Unicode scalar values can be up to 21 bits in length. To
    /// represent those scalar values using 8-bit integers, more than one UTF-8
    /// code unit is often required.
    ///
    ///     let flowermoji = "💐"
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     // 💐 128144
    ///
    ///     for v in flowermoji.utf8 {
    ///         print(v)
    ///     }
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// In the encoded representation of a Unicode scalar value, each UTF-8 code
    /// unit after the first is called a *continuation byte*.
    ///
    /// UTF8View Elements Match Encoded C Strings
    /// =========================================
    ///
    /// Swift streamlines interoperation with C string APIs by letting you pass a
    /// `String` instance to a function as an `Int8` or `UInt8` pointer. When you
    /// call a C function using a `String`, Swift automatically creates a buffer
    /// of UTF-8 code units and passes a pointer to that buffer. The code units
    /// of that buffer match the code units in the string's `utf8` view.
    ///
    /// The following example uses the C `strncmp` function to compare the
    /// beginning of two Swift strings. The `strncmp` function takes two
    /// `const char*` pointers and an integer specifying the number of characters
    /// to compare. Because the strings are identical up to the 14th character,
    /// comparing only those characters results in a return value of `0`.
    ///
    ///     let s1 = "They call me 'Bell'"
    ///     let s2 = "They call me 'Stacey'"
    ///
    ///     print(strncmp(s1, s2, 14))
    ///     // Prints "0"
    ///     print(String(s1.utf8.prefix(14))!)
    ///     // Prints "They call me '"
    ///
    /// Extending the compared character count to 15 includes the differing
    /// characters, so a nonzero result is returned.
    ///
    ///     print(strncmp(s1, s2, 15))
    ///     // Prints "-17"
    ///     print(String(s1.utf8.prefix(15))!)
    ///     // Prints "They call me 'B"
    @frozen public struct UTF8View : Sendable {
    }

    /// A UTF-8 encoding of `self`.
    @inlinable public var utf8: String.UTF8View

    /// A contiguously stored null-terminated UTF-8 representation of the string.
    ///
    /// To access the underlying memory, invoke `withUnsafeBufferPointer` on the
    /// array.
    ///
    ///     let s = "Hello!"
    ///     let bytes = s.utf8CString
    ///     print(bytes)
    ///     // Prints "[72, 101, 108, 108, 111, 33, 0]"
    ///
    ///     bytes.withUnsafeBufferPointer { ptr in
    ///         print(strlen(ptr.baseAddress!))
    ///     }
    ///     // Prints "6"
    public var utf8CString: ContiguousArray<CChar> { get }

    /// Creates a string corresponding to the given sequence of UTF-8 code units.
    @available(swift, introduced: 4.0, message: "Please use failable String.init?(_:UTF8View) when in Swift 3.2 mode")
    @inlinable public init(_ utf8: String.UTF8View)

    /// A view of a string's contents as a collection of Unicode scalar values.
    ///
    /// You can access a string's view of Unicode scalar values by using its
    /// `unicodeScalars` property. Unicode scalar values are the 21-bit codes
    /// that are the basic unit of Unicode. Each scalar value is represented by
    /// a `Unicode.Scalar` instance and is equivalent to a UTF-32 code unit.
    ///
    ///     let flowers = "Flowers 💐"
    ///     for v in flowers.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 128144
    ///
    /// Some characters that are visible in a string are made up of more than one
    /// Unicode scalar value. In that case, a string's `unicodeScalars` view
    /// contains more elements than the string itself.
    ///
    ///     let flag = "🇵🇷"
    ///     for c in flag {
    ///         print(c)
    ///     }
    ///     // 🇵🇷
    ///
    ///     for v in flag.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 127477
    ///     // 127479
    ///
    /// You can convert a `String.UnicodeScalarView` instance back into a string
    /// using the `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is 🎉"
    ///     if let i = favemoji.unicodeScalars.firstIndex(where: { $0.value >= 128 }) {
    ///         let asciiPrefix = String(favemoji.unicodeScalars[..<i])
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    @frozen public struct UnicodeScalarView : Sendable {
    }

    /// Creates a string corresponding to the given collection of Unicode
    /// scalars.
    ///
    /// You can use this initializer to create a new string from a slice of
    /// another string's `unicodeScalars` view.
    ///
    ///     let picnicGuest = "Deserving porcupine"
    ///     if let i = picnicGuest.unicodeScalars.firstIndex(of: " ") {
    ///         let adjective = String(picnicGuest.unicodeScalars[..<i])
    ///         print(adjective)
    ///     }
    ///     // Prints "Deserving"
    ///
    /// The `adjective` constant is created by calling this initializer with a
    /// slice of the `picnicGuest.unicodeScalars` view.
    ///
    /// - Parameter unicodeScalars: A collection of Unicode scalar values.
    @inlinable public init(_ unicodeScalars: String.UnicodeScalarView)

    /// The index type for a string's `unicodeScalars` view.
    public typealias UnicodeScalarIndex = String.UnicodeScalarView.Index

    /// The string's value represented as a collection of Unicode scalar values.
    @inlinable public var unicodeScalars: String.UnicodeScalarView

    /// Creates a new string from the given substring.
    ///
    /// - Parameter substring: A substring to convert to a standalone `String`
    ///   instance.
    ///
    /// - Complexity: O(*n*), where *n* is the length of `substring`.
    @inlinable public init(_ substring: Substring)

    /// Creates a String having the given content.
    ///
    /// If `codeUnits` is an ill-formed code unit sequence, the result is `nil`.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init?(_ codeUnits: Substring.UTF8View)

    /// Creates a String having the given content.
    ///
    /// If `codeUnits` is an ill-formed code unit sequence, the result is `nil`.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init?(_ codeUnits: Substring.UTF16View)

    /// Creates a String having the given content.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init(_ content: Substring.UnicodeScalarView)

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @available(swift 4)
    public subscript(r: Range<String.Index>) -> Substring { get }

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    @inlinable public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a new string with the specified capacity in UTF-8 code units, and
    /// then calls the given closure with a buffer covering the string's
    /// uninitialized memory.
    ///
    /// The closure should return the number of initialized code units,
    /// or 0 if it couldn't initialize the buffer (for example if the
    /// requested capacity was too small).
    ///
    /// This method replaces ill-formed UTF-8 sequences with the Unicode
    /// replacement character (`"\u{FFFD}"`). This may require resizing
    /// the buffer beyond its original capacity.
    ///
    /// The following examples use this initializer with the contents of two
    /// different `UInt8` arrays---the first with a well-formed UTF-8 code unit
    /// sequence, and the second with an ill-formed sequence at the end.
    ///
    ///     let validUTF8: [UInt8] = [0x43, 0x61, 0x66, 0xC3, 0xA9]
    ///     let invalidUTF8: [UInt8] = [0x43, 0x61, 0x66, 0xC3]
    ///
    ///     let cafe1 = String(unsafeUninitializedCapacity: validUTF8.count) {
    ///         _ = $0.initialize(from: validUTF8)
    ///         return validUTF8.count
    ///     }
    ///     // cafe1 == "Café"
    ///
    ///     let cafe2 = String(unsafeUninitializedCapacity: invalidUTF8.count) {
    ///         _ = $0.initialize(from: invalidUTF8)
    ///         return invalidUTF8.count
    ///     }
    ///     // cafe2 == "Caf�"
    ///
    ///     let empty = String(unsafeUninitializedCapacity: 16) { _ in
    ///         // Can't initialize the buffer (e.g. the capacity is too small).
    ///         return 0
    ///     }
    ///     // empty == ""
    ///
    /// - Parameters:
    ///   - capacity: The number of UTF-8 code units worth of memory to allocate
    ///     for the string (excluding the null terminator).
    ///   - initializer: A closure that accepts a buffer covering uninitialized
    ///     memory with room for `capacity` UTF-8 code units, initializes
    ///     that memory, and returns the number of initialized elements.
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public init(unsafeUninitializedCapacity capacity: Int, initializingUTF8With initializer: (_ buffer: UnsafeMutableBufferPointer<UInt8>) throws -> Int) rethrows

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    @inlinable public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : _UnicodeEncoding

    /// Returns a lowercase version of the string.
    ///
    /// Here's an example of transforming a string to all lowercase letters.
    ///
    ///     let cafe = "BBQ Café 🍵"
    ///     print(cafe.lowercased())
    ///     // Prints "bbq café 🍵"
    ///
    /// - Returns: A lowercase copy of the string.
    ///
    /// - Complexity: O(*n*)
    public func lowercased() -> String

    /// Returns an uppercase version of the string.
    ///
    /// The following example transforms a string to uppercase letters:
    ///
    ///     let cafe = "Café 🍵"
    ///     print(cafe.uppercased())
    ///     // Prints "CAFÉ 🍵"
    ///
    /// - Returns: An uppercase copy of the string.
    ///
    /// - Complexity: O(*n*)
    public func uppercased() -> String

    /// Creates an instance from the description of a given
    /// `LosslessStringConvertible` instance.
    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: String, maximum: String) -> ClosedRange<String>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (Character) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (Character) throws -> Bool) rethrows -> Substring

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (Character) throws -> Bool) rethrows -> Substring

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: Index) -> Substring

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: Index) -> Substring

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: Index) -> Substring

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Character) throws -> Bool) rethrows -> [Substring]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: Character, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: Character? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: Character) -> Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (Character) throws -> Bool) rethrows -> Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (Character) throws -> Bool) rethrows -> Character?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (Character) throws -> Bool) rethrows -> Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: Character) -> Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [Character] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [Character]

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: String, rhs: String) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: String, rhs: String) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: String, rhs: String) -> Bool

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: String)

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral value: String)

    /// Creates a new instance from an interpolated string literal.
    ///
    /// Don't call this initializer directly. It's used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     // message == "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public init(stringInterpolation: DefaultStringInterpolation)

    /// Applies the given difference to this collection.
    ///
    /// - Parameter difference: The difference to be applied.
    ///
    /// - Returns: An instance representing the state of the receiver with the
    ///   difference applied, or `nil` if the difference is incompatible with
    ///   the receiver's state.
    ///
    /// - Complexity: O(*n* + *c*), where *n* is `self.count` and *c* is the
    ///   number of changes contained by the parameter.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func applying(_ difference: CollectionDifference<Character>) -> String?

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, Character) -> Bool) -> CollectionDifference<Character> where C : BidirectionalCollection, Character == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<Character> where C : BidirectionalCollection, Character == C.Element

    public static func != (lhs: String, rhs: String) -> Bool

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: DefaultIndices<String> { get }

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<String> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (Character) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: Character) -> Index?

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: String, maximum: String) -> Range<String>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: String) -> PartialRangeUpTo<String>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: String) -> PartialRangeThrough<String>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: String) -> PartialRangeFrom<String>

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring where R : RangeExpression, Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring { get }

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    @inlinable public init(repeating repeatedValue: Character, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    @inlinable public init<S>(_ elements: S) where S : Sequence, Character == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many calls to `append(_:)` on the
    ///   same collection.
    @inlinable public mutating func append(_ newElement: Character)

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf newElements: S) where S : Sequence, Character == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection. If
    ///   `i == endIndex`, this method is equivalent to `append(_:)`.
    @inlinable public mutating func insert(_ newElement: Character, at i: Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If `i == endIndex`, this method
    ///   is equivalent to `append(contentsOf:)`.
    @inlinable public mutating func insert<C>(contentsOf newElements: C, at i: Index) where C : Collection, Character == C.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   collection's end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func remove(at position: Index) -> Character

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange(_ bounds: Range<Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst() -> Character

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    @inlinable public mutating func reserveCapacity(_ n: Int)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, the complexity
    ///   is O(*m*).
    @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, Character == C.Element, Index == R.Bound

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, Index == R.Bound

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> Character?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> Character

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Creates a new collection by concatenating the elements of a collection and
    /// a sequence.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of an integer array and a `Range<Int>` instance.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let moreNumbers = numbers + (5...10)
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: A collection or finite sequence.
    @inlinable public static func + <Other>(lhs: String, rhs: Other) -> String where Other : Sequence, Character == Other.Element

    /// Creates a new collection by concatenating the elements of a sequence and a
    /// collection.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of a `Range<Int>` instance and an integer array.
    ///
    ///     let numbers = [7, 8, 9, 10]
    ///     let moreNumbers = (1...6) + numbers
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of argument on the right-hand side.
    /// In the example above, `moreNumbers` has the same type as `numbers`, which
    /// is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A collection or finite sequence.
    ///   - rhs: A range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Other, rhs: String) -> String where Other : Sequence, Character == Other.Element

    /// Appends the elements of a sequence to a range-replaceable collection.
    ///
    /// Use this operator to append the elements of a sequence to the end of
    /// range-replaceable collection with same `Element` type. This example
    /// appends the elements of a `Range<Int>` instance to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers += 10...15
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameters:
    ///   - lhs: The array to append to.
    ///   - rhs: A collection or finite sequence.
    ///
    /// - Complexity: O(*m*), where *m* is the length of the right-hand-side
    ///   argument.
    @inlinable public static func += <Other>(lhs: inout String, rhs: Other) where Other : Sequence, Character == Other.Element

    /// Creates a new collection by concatenating the elements of two collections.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of two integer arrays.
    ///
    ///     let lowerNumbers = [1, 2, 3, 4]
    ///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
    ///     let allNumbers = lowerNumbers + higherNumbers
    ///     print(allNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: Another range-replaceable collection.
    @inlinable public static func + <Other>(lhs: String, rhs: Other) -> String where Other : RangeReplaceableCollection, Character == Other.Element

    /// Returns a new collection of the same type containing, in order, the
    /// elements of the original collection that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned collection.
    /// - Returns: A collection of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @available(swift 4.0)
    @inlinable public func filter(_ isIncluded: (Character) throws -> Bool) rethrows -> String

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. The order of the remaining elements is preserved.
    /// This example removes all the vowels from a string:
    ///
    ///     var phrase = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     phrase.removeAll(where: { vowels.contains($0) })
    ///     // phrase == "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter shouldBeRemoved: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(where shouldBeRemoved: (Character) throws -> Bool) rethrows

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<String>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (Character) throws -> T) rethrows -> [T]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (Character) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (Character) throws -> Bool) rethrows -> Character?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Character>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<String>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Character?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Character?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> Character?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> Character?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Character, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Character == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Character, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Character) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Character) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (Character) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (Character) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [Character]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (Character, Character) throws -> Bool) rethrows -> [Character]

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    @inlinable public static func != <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func >= <RHS>(lhs: String, rhs: RHS) -> Bool where RHS : StringProtocol

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `other`.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, subrange: Range<Index>, maxReplacements: Int = .max) -> String where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) -> String where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Replaces all occurrences of a target sequence with a given collection
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) where C : Collection, Replacement : Collection, Character == C.Element, C.Element == Replacement.Element

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `regex`.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` in `subrange` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, subrange: Range<Index>, maxReplacements: Int = .max) -> String where Replacement : Collection, Replacement.Element == Character

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, maxReplacements: Int = .max) -> String where Replacement : Collection, Replacement.Element == Character

    /// Replaces all occurrences of the sequence matching the given regex with
    /// a given collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<Replacement>(_ regex: some RegexComponent, with replacement: Replacement, maxReplacements: Int = .max) where Replacement : Collection, Replacement.Element == Character

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (Character) throws -> Bool) rethrows

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, Character == Prefix.Element

    /// Removes the initial elements that matches the given regex.
    /// - Parameter regex: The regex to remove from this collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(_ regex: some RegexComponent)

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another regex match.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - subrange: The range in the collection in which to search for `regex`.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Output, Replacement>(_ regex: some RegexComponent, subrange: Range<Index>, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows -> String where Replacement : Collection, Replacement.Element == Character

    /// Returns a new collection in which all occurrences of a sequence matching
    /// the given regex are replaced by another collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    /// - Returns: A new collection in which all occurrences of subsequence
    /// matching `regex` are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<Output, Replacement>(_ regex: some RegexComponent, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows -> String where Replacement : Collection, Replacement.Element == Character

    /// Replaces all occurrences of the sequence matching the given regex with
    /// a given collection.
    /// - Parameters:
    ///   - regex: A regex describing the sequence to replace.
    ///   - maxReplacements: A number specifying how many occurrences of the
    ///   sequence matching `regex` to replace. Default is `Int.max`.
    ///   - replacement: A closure that receives the full match information,
    ///   including captures, and returns a replacement collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<Output, Replacement>(_ regex: some RegexComponent, maxReplacements: Int = .max, with replacement: (Regex<Output>.Match) throws -> Replacement) rethrows where Replacement : Collection, Replacement.Element == Character

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Character == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (Character) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (Character) throws -> Bool) rethrows -> Bool

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring where Prefix : Sequence, Character == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (Character) throws -> Bool) rethrows -> Substring

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<Index>] where C : Collection, Character == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Index>? where C : Collection, Character == C.Element

    /// Returns a collection containing all matches of the specified regex.
    /// - Parameter regex: The regex to search for.
    /// - Returns: A collection of matches of `regex`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func matches<Output>(of r: some RegexComponent) -> [Regex<Output>.Match]

    /// Returns the first match of the specified regex within the collection.
    /// - Parameter regex: The regex to search for.
    /// - Returns: The first match of `regex` in the collection, or `nil` if
    /// there isn't a match.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstMatch<Output>(of r: some RegexComponent) -> Regex<Output>.Match?

    /// Returns a new collection of the same type by removing `prefix` from the
    /// start.
    /// - Parameter prefix: The collection to remove from this collection.
    /// - Returns: A collection containing the elements that does not match
    /// `prefix` from the start.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(_ regex: some RegexComponent) -> Substring

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    ///
    /// - Parameter regex: The regex to search for.
    /// - Returns: A collection or ranges in the receiver of all occurrences of
    /// `regex`. Returns an empty collection if `regex` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges(of regex: some RegexComponent) -> [Range<Index>]

    /// Finds and returns the range of the first occurrence of a given regex
    /// within the collection.
    /// - Parameter regex: The regex to search for.
    /// - Returns: A range in the collection of the first occurrence of `regex`.
    /// Returns `nil` if `regex` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange(of regex: some RegexComponent) -> Range<Index>?

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Index>? where C : Collection, Character == C.Element

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: Character) -> Bool
}

/// Default implementations of core requirements
extension String {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: Character? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Default implementation for forward collections.
extension String {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Index)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Index, offsetBy distance: Int, limitedBy limit: Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> Character? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> Character?
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension String {

    /// Checks for a match against the string in its entirety.
    ///
    /// - Parameter r: The regular expression being matched.
    /// - Returns: The match, or `nil` if no match was found.
    public func wholeMatch<R>(of r: R) -> Regex<R.RegexOutput>.Match? where R : RegexComponent

    /// Checks for a match against the string, starting at its beginning.
    ///
    /// - Parameter r: The regular expression being matched.
    /// - Returns: The match, or `nil` if no match was found.
    public func prefixMatch<R>(of r: R) -> Regex<R.RegexOutput>.Match? where R : RegexComponent
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension String {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in the specified regex.
    ///
    /// - Parameter regex: A regex to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence matches the
    ///   beginning of `regex`; otherwise, `false`.
    public func starts(with regex: some RegexComponent) -> Bool
}

/// Default implementation for bidirectional collections.
extension String {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Index)
}

extension String : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// Do not call this initializer directly. It is used by the compiler when you
    /// initialize a string using a string literal. For example:
    ///
    ///     let nextStop = "Clark & Lake"
    ///
    /// This assignment to the `nextStop` constant calls this string literal
    /// initializer behind the scenes.
    @inlinable public init(stringLiteral value: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = String
}

extension String : CustomDebugStringConvertible {

    /// A representation of the string that is suitable for debugging.
    public var debugDescription: String { get }
}

extension String : CustomStringConvertible {

    /// The value of this string.
    ///
    /// Using this property directly is discouraged. Instead, use simple
    /// assignment to create a new constant or variable equal to this string.
    @inlinable public var description: String { get }
}

extension String : BidirectionalCollection {

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring

    /// A type representing the sequence's elements.
    public typealias Element = Character

    /// The position of the first character in a nonempty string.
    ///
    /// In an empty string, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: String.Index { get }

    /// A string's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// In an empty string, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: String.Index { get }

    /// The number of characters in a string.
    public var count: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: String.Index) -> String.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: String.Index) -> String.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    /// - Complexity: O(*n*), where *n* is the absolute value of `distance`.
    public func index(_ i: String.Index, offsetBy distance: Int) -> String.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the absolute value of `distance`.
    public func index(_ i: String.Index, offsetBy distance: Int, limitedBy limit: String.Index) -> String.Index?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    ///
    /// - Complexity: O(*n*), where *n* is the resulting distance.
    public func distance(from start: String.Index, to end: String.Index) -> Int

    /// Accesses the character at the given position.
    ///
    /// You can use the same indices for subscripting a string and its substring.
    /// For example, this code finds the first letter after the first space:
    ///
    ///     let str = "Greetings, friend! How are you?"
    ///     let firstSpace = str.firstIndex(of: " ") ?? str.endIndex
    ///     let substr = str[firstSpace...]
    ///     if let nextCapital = substr.firstIndex(where: { $0 >= "A" && $0 <= "Z" }) {
    ///         print("Capital after a space: \(str[nextCapital])")
    ///     }
    ///     // Prints "Capital after a space: H"
    ///
    /// - Parameter i: A valid index of the string. `i` must be less than the
    ///   string's end index.
    public subscript(i: String.Index) -> Character { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<String>
}

extension String : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

extension String : TextOutputStreamable {

    /// Writes the string into the given output stream.
    ///
    /// - Parameter target: An output stream.
    @inlinable public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension String : TextOutputStream {

    /// Appends the given string to this string.
    ///
    /// - Parameter other: A string to append.
    public mutating func write(_ other: String)
}

extension String : CustomReflectable {

    /// A mirror that reflects the `String` instance.
    public var customMirror: Mirror { get }
}

@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension String : CodingKeyRepresentable {

    @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
    public var codingKey: CodingKey { get }

    @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
    public init?<T>(codingKey: T) where T : CodingKey
}

extension String : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension String : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: String, rhs: String) -> Bool
}

extension String : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < (lhs: String, rhs: String) -> Bool
}

extension String : StringProtocol {

    /// The type each segment of a string literal containing interpolations
    /// should be appended to.
    ///
    /// The `StringLiteralType` of an interpolation type must match the
    /// `StringLiteralType` of the conforming type.
    public typealias StringInterpolation = DefaultStringInterpolation
}

extension String : RangeReplaceableCollection {

    /// Creates a string representing the given character repeated the specified
    /// number of times.
    ///
    /// For example, use this initializer to create a string with ten `"0"`
    /// characters in a row.
    ///
    ///     let zeroes = String(repeating: "0" as Character, count: 10)
    ///     print(zeroes)
    ///     // Prints "0000000000"
    ///
    /// - Parameters:
    ///   - repeatedValue: The character to repeat.
    ///   - count: The number of times to repeat `repeatedValue` in the
    ///     resulting string.
    public init(repeating repeatedValue: Character, count: Int)

    /// Creates a new string containing the characters in the given sequence.
    ///
    /// You can use this initializer to create a new string from the result of
    /// one or more collection operations on a string's characters. For example:
    ///
    ///     let str = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     let disemvoweled = String(str.lazy.filter { !vowels.contains($0) })
    ///
    ///     print(disemvoweled)
    ///     // Prints "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter other: A string instance or another sequence of
    ///   characters.
    public init<S>(_ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character

    /// Creates a new string containing the characters in the given sequence.
    ///
    /// You can use this initializer to create a new string from the result of
    /// one or more collection operations on a string's characters. For example:
    ///
    ///     let str = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     let disemvoweled = String(str.lazy.filter { !vowels.contains($0) })
    ///
    ///     print(disemvoweled)
    ///     // Prints "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter characters: A string instance or another sequence of
    ///   characters.
    public init<S>(_ characters: S) where S : Sequence, S.Element == Character

    /// Reserves enough space in the string's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because each character in a string can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding characters to a string after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*)
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given string to this string.
    ///
    /// The following example builds a customized greeting by using the
    /// `append(_:)` method:
    ///
    ///     var greeting = "Hello, "
    ///     if let name = getUserName() {
    ///         greeting.append(name)
    ///     } else {
    ///         greeting.append("friend")
    ///     }
    ///     print(greeting)
    ///     // Prints "Hello, friend"
    ///
    /// - Parameter other: Another string.
    public mutating func append(_ other: String)

    /// Appends the given character to the string.
    ///
    /// The following example adds an emoji globe to the end of a string.
    ///
    ///     var globe = "Globe "
    ///     globe.append("🌍")
    ///     print(globe)
    ///     // Prints "Globe 🌍"
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ c: Character)

    public mutating func append(contentsOf newElements: String)

    public mutating func append(contentsOf newElements: Substring)

    /// Appends the characters in the given sequence to the string.
    ///
    /// - Parameter newElements: A sequence of characters.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == Character

    /// Replaces the text within the specified bounds with the given characters.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new characters to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C>(_ subrange: Range<String.Index>, with newElements: C) where C : Collection, C.Element == Character

    /// Inserts a new character at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElement: The new character to insert into the string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends `newElement` to the string.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the string.
    public mutating func insert(_ newElement: Character, at i: String.Index)

    /// Inserts a collection of characters at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElements: A collection of `Character` elements to insert into the
    ///     string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends the contents of `newElements` to the
    ///     string.
    ///
    /// - Complexity: O(*n*), where *n* is the combined length of the string and
    ///   `newElements`.
    public mutating func insert<S>(contentsOf newElements: S, at i: String.Index) where S : Collection, S.Element == Character

    /// Removes and returns the character at the specified position.
    ///
    /// All the elements following `i` are moved to close the gap. This example
    /// removes the hyphen from the middle of a string.
    ///
    ///     var nonempty = "non-empty"
    ///     if let i = nonempty.firstIndex(of: "-") {
    ///         nonempty.remove(at: i)
    ///     }
    ///     print(nonempty)
    ///     // Prints "nonempty"
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter i: The position of the character to remove. `i` must be a
    ///   valid index of the string that is not equal to the string's end index.
    /// - Returns: The character that was removed.
    public mutating func remove(at i: String.Index) -> Character

    /// Removes the characters in the given range.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string and not
    ///   equal to the string's end index.
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string.
    public mutating func removeSubrange(_ bounds: Range<String.Index>)

    /// Replaces this string with the empty string.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter keepCapacity: Pass `true` to prevent the release of the
    ///   string's allocated storage. Retaining the storage can be a useful
    ///   optimization when you're planning to grow the string again. The
    ///   default value is `false`.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)
}

/// Default implementations of core requirements
extension String.UTF16View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: UTF16.CodeUnit? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Default implementation for bidirectional collections.
extension String.UTF16View {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout String.Index)
}

extension String.UTF16View {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(swift, deprecated: 4.2, message: "UTF16View.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @frozen public struct Iterator : IteratorProtocol, Sendable {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        @inlinable public mutating func next() -> UInt16?

        /// The type of element traversed by the iterator.
        public typealias Element = UInt16
    }

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> String.UTF16View.Iterator

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UTF16View

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(r: Range<String.UTF16View.Index>) -> Substring.UTF16View { get }

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UTF16View

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UTF16View

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (UTF16.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UTF16View

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Substring.UTF16View

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UTF16View

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Substring.UTF16View

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.Index) -> Substring.UTF16View

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.Index) -> Substring.UTF16View

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.Index) -> Substring.UTF16View

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UTF16.CodeUnit) throws -> Bool) rethrows -> [Substring.UTF16View]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: UTF16.CodeUnit, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UTF16View]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: UTF16.CodeUnit? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: UTF16.CodeUnit) -> String.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> String.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> String.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: UTF16.CodeUnit) -> String.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [UTF16.CodeUnit] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [UTF16.CodeUnit]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, UTF16.CodeUnit) -> Bool) -> CollectionDifference<UTF16.CodeUnit> where C : BidirectionalCollection, UTF16.CodeUnit == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<UTF16.CodeUnit> where C : BidirectionalCollection, UTF16.CodeUnit == C.Element

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: DefaultIndices<String.UTF16View> { get }

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<String.UTF16View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (UTF16.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: UTF16.CodeUnit) -> String.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UTF16View where R : RangeExpression, String.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UTF16View { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<String.UTF16View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (UTF16.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (UTF16.CodeUnit) throws -> Bool) rethrows -> [UTF16.CodeUnit]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (UTF16.CodeUnit) throws -> Void) rethrows

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UTF16View where Prefix : Sequence, UTF16.CodeUnit == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Substring.UTF16View

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<UTF16.CodeUnit>) throws -> R) rethrows -> R?

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> UTF16.CodeUnit?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> UTF16.CodeUnit?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UTF16.CodeUnit, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, UTF16.CodeUnit == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UTF16.CodeUnit, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: UTF16.CodeUnit) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UTF16.CodeUnit) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, UTF16.CodeUnit) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (UTF16.CodeUnit) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (UTF16.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [UTF16.CodeUnit]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> [UTF16.CodeUnit]

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.Index>] where C : Collection, UTF16.CodeUnit == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, UTF16.CodeUnit == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, UTF16.CodeUnit == C.Element

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<String.UTF16View>
}

/// Default implementation for forward collections.
extension String.UTF16View {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout String.Index)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int, limitedBy limit: String.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> UTF16.CodeUnit? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> UTF16.CodeUnit?
}

extension String.UTF16View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// The position of the first code unit if the `String` is
    /// nonempty; identical to `endIndex` otherwise.
    @inlinable public var startIndex: String.UTF16View.Index { get }

    /// The "past the end" position---that is, the position one greater than
    /// the last valid subscript argument.
    ///
    /// In an empty UTF-16 view, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: String.UTF16View.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable public func index(after idx: String.UTF16View.Index) -> String.UTF16View.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before idx: String.UTF16View.Index) -> String.UTF16View.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: String.UTF16View.Index, offsetBy n: Int) -> String.UTF16View.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: String.UTF16View.Index, offsetBy n: Int, limitedBy limit: String.UTF16View.Index) -> String.UTF16View.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: String.UTF16View.Index, to end: String.UTF16View.Index) -> Int

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }

    /// Accesses the code unit at the given position.
    ///
    /// The following example uses the subscript to print the value of a
    /// string's first UTF-16 code unit.
    ///
    ///     let greeting = "Hello, friend!"
    ///     let i = greeting.utf16.startIndex
    ///     print("First character's UTF-16 code unit: \(greeting.utf16[i])")
    ///     // Prints "First character's UTF-16 code unit: 72"
    ///
    /// - Parameter position: A valid index of the view. `position` must be
    ///   less than the view's end index.
    @inlinable public subscript(idx: String.UTF16View.Index) -> UTF16.CodeUnit { get }

    /// A type representing the sequence's elements.
    public typealias Element = UTF16.CodeUnit

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<String.UTF16View>
}

extension String.UTF16View : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

extension String.UTF16View : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension String.UTF16View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-16 view of a string.
    public var customMirror: Mirror { get }
}

extension String.Index {

    /// The UTF-16 code unit offset corresponding to this index.
    public func utf16Offset<S>(in s: S) -> Int where S : StringProtocol

    /// The offset into a string's code units for this index.
    @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use utf16Offset(in:) to achieve the same behavior.")
    @inlinable public var encodedOffset: Int { get }

    /// Creates a new index at the specified UTF-16 code unit offset
    ///
    /// - Parameter offset: An offset in UTF-16 code units.
    public init<S>(utf16Offset offset: Int, in s: S) where S : StringProtocol

    /// Creates a new index at the specified code unit offset.
    ///
    /// - Parameter offset: An offset in code units.
    @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use String.Index(utf16Offset:in:) to achieve the same behavior.")
    @inlinable public init(encodedOffset offset: Int)

    /// Creates an index in the given string that corresponds exactly to the
    /// specified position.
    ///
    /// If the index passed as `sourcePosition` represents the start of an
    /// extended grapheme cluster---the element type of a string---then the
    /// initializer succeeds.
    ///
    /// The following example converts the position of the Unicode scalar `"e"`
    /// into its corresponding position in the string. The character at that
    /// position is the composed `"é"` character.
    ///
    ///     let cafe = "Cafe\u{0301}"
    ///     print(cafe)
    ///     // Prints "Café"
    ///
    ///     let scalarsIndex = cafe.unicodeScalars.firstIndex(of: "e")!
    ///     let stringIndex = String.Index(scalarsIndex, within: cafe)!
    ///
    ///     print(cafe[...stringIndex])
    ///     // Prints "Café"
    ///
    /// If the index passed as `sourcePosition` doesn't have an exact
    /// corresponding position in `target`, the result of the initializer is
    /// `nil`. For example, an attempt to convert the position of the combining
    /// acute accent (`"\u{0301}"`) fails. Combining Unicode scalars do not have
    /// their own position in a string.
    ///
    ///     let nextScalarsIndex = cafe.unicodeScalars.index(after: scalarsIndex)
    ///     let nextStringIndex = String.Index(nextScalarsIndex, within: cafe)
    ///
    ///     print(nextStringIndex)
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in a view of the `target` parameter.
    ///     `sourcePosition` must be a valid index of at least one of the views
    ///     of `target`.
    ///   - target: The string referenced by the resulting index.
    public init?(_ sourcePosition: String.Index, within target: String)

    /// Creates an index in the given string that corresponds exactly to the
    /// specified position.
    ///
    /// If the index passed as `sourcePosition` represents the start of an
    /// extended grapheme cluster---the element type of a string---then the
    /// initializer succeeds.
    ///
    /// The following example converts the position of the Unicode scalar `"e"`
    /// into its corresponding position in the string. The character at that
    /// position is the composed `"é"` character.
    ///
    ///     let cafe = "Cafe\u{0301}"
    ///     print(cafe)
    ///     // Prints "Café"
    ///
    ///     let scalarsIndex = cafe.unicodeScalars.firstIndex(of: "e")!
    ///     let stringIndex = String.Index(scalarsIndex, within: cafe)!
    ///
    ///     print(cafe[...stringIndex])
    ///     // Prints "Café"
    ///
    /// If the index passed as `sourcePosition` doesn't have an exact
    /// corresponding position in `target`, the result of the initializer is
    /// `nil`. For example, an attempt to convert the position of the combining
    /// acute accent (`"\u{0301}"`) fails. Combining Unicode scalars do not have
    /// their own position in a string.
    ///
    ///     let nextScalarsIndex = cafe.unicodeScalars.index(after: scalarsIndex)
    ///     let nextStringIndex = String.Index(nextScalarsIndex, within: cafe)
    ///
    ///     print(nextStringIndex)
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in a view of the `target` parameter.
    ///     `sourcePosition` must be a valid index of at least one of the views
    ///     of `target`.
    ///   - target: The string referenced by the resulting index.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public init?<S>(_ sourcePosition: String.Index, within target: S) where S : StringProtocol

    /// Returns the position in the given UTF-8 view that corresponds exactly to
    /// this index.
    ///
    /// This example first finds the position of the character `"é"`, and then
    /// uses this method find the same position in the string's `utf8` view.
    ///
    ///     let cafe = "Café"
    ///     if let i = cafe.firstIndex(of: "é") {
    ///         let j = i.samePosition(in: cafe.utf8)!
    ///         print(Array(cafe.utf8[j...]))
    ///     }
    ///     // Prints "[195, 169]"
    ///
    /// - Parameter utf8: The view to use for the index conversion. This index
    ///   must be a valid index of at least one view of the string shared by
    ///   `utf8`.
    /// - Returns: The position in `utf8` that corresponds exactly to this index.
    ///   If this index does not have an exact corresponding position in `utf8`,
    ///   this method returns `nil`. For example, an attempt to convert the
    ///   position of a UTF-16 trailing surrogate returns `nil`.
    public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index?

    /// Returns the position in the given UTF-16 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf16)`.
    ///
    /// This example first finds the position of the character `"é"` and then
    /// uses this method find the same position in the string's `utf16` view.
    ///
    ///     let cafe = "Café"
    ///     if let i = cafe.firstIndex(of: "é") {
    ///         let j = i.samePosition(in: cafe.utf16)!
    ///         print(cafe.utf16[j])
    ///     }
    ///     // Prints "233"
    ///
    /// - Parameter utf16: The view to use for the index conversion. This index
    ///   must be a valid index of at least one view of the string shared by
    ///   `utf16`.
    /// - Returns: The position in `utf16` that corresponds exactly to this
    ///   index. If this index does not have an exact corresponding position in
    ///   `utf16`, this method returns `nil`. For example, an attempt to convert
    ///   the position of a UTF-8 continuation byte returns `nil`.
    public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index?

    /// Creates an index in the given UTF-16 view that corresponds exactly to the
    /// specified string position.
    ///
    /// If the index passed as `sourcePosition` represents either the start of a
    /// Unicode scalar value or the position of a UTF-16 trailing surrogate,
    /// then the initializer succeeds. If `sourcePosition` does not have an
    /// exact corresponding position in `target`, then the result is `nil`. For
    /// example, an attempt to convert the position of a UTF-8 continuation byte
    /// results in `nil`.
    ///
    /// The following example finds the position of a space in a string and then
    /// converts that position to an index in the string's `utf16` view.
    ///
    ///     let cafe = "Café 🍵"
    ///
    ///     let stringIndex = cafe.firstIndex(of: "é")!
    ///     let utf16Index = String.Index(stringIndex, within: cafe.utf16)!
    ///
    ///     print(String(cafe.utf16[...utf16Index])!)
    ///     // Prints "Café"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in at least one of the views of the string
    ///     shared by `target`.
    ///   - target: The `UTF16View` in which to find the new position.
    public init?(_ idx: String.Index, within target: String.UTF16View)

    /// Returns the position in the given view of Unicode scalars that
    /// corresponds exactly to this index.
    ///
    /// This index must be a valid index of `String(unicodeScalars).utf16`.
    ///
    /// This example first finds the position of a space (UTF-16 code point `32`)
    /// in a string's `utf16` view and then uses this method to find the same
    /// position in the string's `unicodeScalars` view.
    ///
    ///     let cafe = "Café 🍵"
    ///     let i = cafe.utf16.firstIndex(of: 32)!
    ///     let j = i.samePosition(in: cafe.unicodeScalars)!
    ///     print(String(cafe.unicodeScalars[..<j]))
    ///     // Prints "Café"
    ///
    /// - Parameter unicodeScalars: The view to use for the index conversion.
    ///   This index must be a valid index of at least one view of the string
    ///   shared by `unicodeScalars`.
    /// - Returns: The position in `unicodeScalars` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `unicodeScalars`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-16 trailing surrogate
    ///   returns `nil`.
    public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> String.UnicodeScalarIndex?

    /// Creates an index in the given UTF-8 view that corresponds exactly to the
    /// specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the string's
    /// `utf8` view.
    ///
    ///     let cafe = "Café 🍵"
    ///
    ///     let utf16Index = cafe.utf16.firstIndex(of: 32)!
    ///     let utf8Index = String.UTF8View.Index(utf16Index, within: cafe.utf8)!
    ///
    ///     print(Array(cafe.utf8[..<utf8Index]))
    ///     // Prints "[67, 97, 102, 195, 169]"
    ///
    /// If the position passed in `utf16Index` doesn't have an exact
    /// corresponding position in `utf8`, the result of the initializer is
    /// `nil`. For example, because UTF-8 and UTF-16 represent high Unicode code
    /// points differently, an attempt to convert the position of the trailing
    /// surrogate of a UTF-16 surrogate pair fails.
    ///
    /// The next example attempts to convert the indices of the two UTF-16 code
    /// points that represent the teacup emoji (`"🍵"`). The index of the lead
    /// surrogate is successfully converted to a position in `utf8`, but the
    /// index of the trailing surrogate is not.
    ///
    ///     let emojiHigh = cafe.utf16.index(after: utf16Index)
    ///     print(String.UTF8View.Index(emojiHigh, within: cafe.utf8))
    ///     // Prints "Optional(String.Index(...))"
    ///
    ///     let emojiLow = cafe.utf16.index(after: emojiHigh)
    ///     print(String.UTF8View.Index(emojiLow, within: cafe.utf8))
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in a `String` or one of its views.
    ///   - target: The `UTF8View` in which to find the new position.
    public init?(_ idx: String.Index, within target: String.UTF8View)

    /// Creates an index in the given Unicode scalars view that corresponds
    /// exactly to the specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the string's
    /// `unicodeScalars` view:
    ///
    ///     let cafe = "Café 🍵"
    ///
    ///     let utf16Index = cafe.utf16.firstIndex(of: 32)!
    ///     let scalarIndex = String.Index(utf16Index, within: cafe.unicodeScalars)!
    ///
    ///     print(String(cafe.unicodeScalars[..<scalarIndex]))
    ///     // Prints "Café"
    ///
    /// If the index passed as `sourcePosition` doesn't have an exact
    /// corresponding position in `unicodeScalars`, the result of the
    /// initializer is `nil`. For example, an attempt to convert the position of
    /// the trailing surrogate of a UTF-16 surrogate pair results in `nil`.
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in the `utf16` view of a string.
    ///     `utf16Index` must be an element of
    ///     `String(unicodeScalars).utf16.indices`.
    ///   - unicodeScalars: The `UnicodeScalarView` in which to find the new
    ///     position.
    public init?(_ sourcePosition: String.Index, within unicodeScalars: String.UnicodeScalarView)

    /// Returns the position in the given string that corresponds exactly to this
    /// index.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method find the same position
    /// in the string.
    ///
    ///     let cafe = "Café 🍵"
    ///     let i = cafe.unicodeScalars.firstIndex(of: "🍵")!
    ///     let j = i.samePosition(in: cafe)!
    ///     print(cafe[j...])
    ///     // Prints "🍵"
    ///
    /// - Parameter characters: The string to use for the index conversion.
    ///   This index must be a valid index of at least one view of `characters`.
    /// - Returns: The position in `characters` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `characters`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-8 continuation byte
    ///   returns `nil`.
    public func samePosition(in characters: String) -> String.Index?

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: String.Index, maximum: String.Index) -> ClosedRange<String.Index>

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: String.Index, rhs: String.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: String.Index, rhs: String.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: String.Index, rhs: String.Index) -> Bool

    public static func != (lhs: String.Index, rhs: String.Index) -> Bool

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: String.Index, maximum: String.Index) -> Range<String.Index>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: String.Index) -> PartialRangeUpTo<String.Index>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: String.Index) -> PartialRangeThrough<String.Index>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: String.Index) -> PartialRangeFrom<String.Index>
}

extension String.Index : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: String.Index, rhs: String.Index) -> Bool
}

extension String.Index : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < (lhs: String.Index, rhs: String.Index) -> Bool
}

extension String.Index : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @inlinable public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

/// In Swift 3.2, in the absence of type context,
///
///   someString.unicodeScalars[
///     someString.unicodeScalars.startIndex
///     ..< someString.unicodeScalars.endIndex]
///
/// was deduced to be of type `String.UnicodeScalarView`.  Provide a
/// more-specific Swift-3-only `subscript` overload that continues to produce
/// `String.UnicodeScalarView`.
extension String.UnicodeScalarView {

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UnicodeScalarView

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @available(swift 4)
    public subscript(r: Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence { get }
}

/// Default implementation for bidirectional collections.
extension String.UnicodeScalarView {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout String.Index)
}

extension String.UnicodeScalarView {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(swift, deprecated: 4.2, message: "UnicodeScalarView.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @frozen public struct Iterator : IteratorProtocol, Sendable {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        @inlinable public mutating func next() -> Unicode.Scalar?

        /// The type of element traversed by the iterator.
        public typealias Element = Unicode.Scalar
    }

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> String.UnicodeScalarView.Iterator

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UnicodeScalarView

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UnicodeScalarView

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (Unicode.Scalar) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UnicodeScalarView

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UnicodeScalarView

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.Index) -> Substring.UnicodeScalarView

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.Index) -> Substring.UnicodeScalarView

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.Index) -> Substring.UnicodeScalarView

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Unicode.Scalar) throws -> Bool) rethrows -> [Substring.UnicodeScalarView]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: Unicode.Scalar, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UnicodeScalarView]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: Unicode.Scalar? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: Unicode.Scalar) -> String.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (Unicode.Scalar) throws -> Bool) rethrows -> String.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Unicode.Scalar?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (Unicode.Scalar) throws -> Bool) rethrows -> String.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: Unicode.Scalar) -> String.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [Unicode.Scalar] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [Unicode.Scalar]

    /// Applies the given difference to this collection.
    ///
    /// - Parameter difference: The difference to be applied.
    ///
    /// - Returns: An instance representing the state of the receiver with the
    ///   difference applied, or `nil` if the difference is incompatible with
    ///   the receiver's state.
    ///
    /// - Complexity: O(*n* + *c*), where *n* is `self.count` and *c* is the
    ///   number of changes contained by the parameter.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func applying(_ difference: CollectionDifference<Unicode.Scalar>) -> String.UnicodeScalarView?

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, Unicode.Scalar) -> Bool) -> CollectionDifference<Unicode.Scalar> where C : BidirectionalCollection, Unicode.Scalar == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<Unicode.Scalar> where C : BidirectionalCollection, Unicode.Scalar == C.Element

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: DefaultIndices<String.UnicodeScalarView> { get }

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<String.UnicodeScalarView> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (Unicode.Scalar) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: Unicode.Scalar) -> String.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UnicodeScalarView where R : RangeExpression, String.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UnicodeScalarView { get }

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    @inlinable public init(repeating repeatedValue: Unicode.Scalar, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    @inlinable public init<S>(_ elements: S) where S : Sequence, Unicode.Scalar == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many calls to `append(_:)` on the
    ///   same collection.
    @inlinable public mutating func append(_ newElement: Unicode.Scalar)

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf newElements: S) where S : Sequence, Unicode.Scalar == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection. If
    ///   `i == endIndex`, this method is equivalent to `append(_:)`.
    @inlinable public mutating func insert(_ newElement: Unicode.Scalar, at i: String.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If `i == endIndex`, this method
    ///   is equivalent to `append(contentsOf:)`.
    @inlinable public mutating func insert<C>(contentsOf newElements: C, at i: String.Index) where C : Collection, Unicode.Scalar == C.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   collection's end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func remove(at position: String.Index) -> Unicode.Scalar

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange(_ bounds: Range<String.Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst(_ k: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeFirst() -> Unicode.Scalar

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    @inlinable public mutating func reserveCapacity(_ n: Int)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, the complexity
    ///   is O(*m*).
    @inlinable public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, Unicode.Scalar == C.Element, String.Index == R.Bound

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, String.Index == R.Bound

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func popLast() -> Unicode.Scalar?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public mutating func removeLast() -> Unicode.Scalar

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter k: The number of elements to remove from the collection.
    ///   `k` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*k*), where *k* is the specified number of elements.
    @inlinable public mutating func removeLast(_ k: Int)

    /// Creates a new collection by concatenating the elements of a collection and
    /// a sequence.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of an integer array and a `Range<Int>` instance.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let moreNumbers = numbers + (5...10)
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: A collection or finite sequence.
    @inlinable public static func + <Other>(lhs: String.UnicodeScalarView, rhs: Other) -> String.UnicodeScalarView where Other : Sequence, Unicode.Scalar == Other.Element

    /// Creates a new collection by concatenating the elements of a sequence and a
    /// collection.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of a `Range<Int>` instance and an integer array.
    ///
    ///     let numbers = [7, 8, 9, 10]
    ///     let moreNumbers = (1...6) + numbers
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of argument on the right-hand side.
    /// In the example above, `moreNumbers` has the same type as `numbers`, which
    /// is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A collection or finite sequence.
    ///   - rhs: A range-replaceable collection.
    @inlinable public static func + <Other>(lhs: Other, rhs: String.UnicodeScalarView) -> String.UnicodeScalarView where Other : Sequence, Unicode.Scalar == Other.Element

    /// Appends the elements of a sequence to a range-replaceable collection.
    ///
    /// Use this operator to append the elements of a sequence to the end of
    /// range-replaceable collection with same `Element` type. This example
    /// appends the elements of a `Range<Int>` instance to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers += 10...15
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameters:
    ///   - lhs: The array to append to.
    ///   - rhs: A collection or finite sequence.
    ///
    /// - Complexity: O(*m*), where *m* is the length of the right-hand-side
    ///   argument.
    @inlinable public static func += <Other>(lhs: inout String.UnicodeScalarView, rhs: Other) where Other : Sequence, Unicode.Scalar == Other.Element

    /// Creates a new collection by concatenating the elements of two collections.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of two integer arrays.
    ///
    ///     let lowerNumbers = [1, 2, 3, 4]
    ///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
    ///     let allNumbers = lowerNumbers + higherNumbers
    ///     print(allNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: Another range-replaceable collection.
    @inlinable public static func + <Other>(lhs: String.UnicodeScalarView, rhs: Other) -> String.UnicodeScalarView where Other : RangeReplaceableCollection, Unicode.Scalar == Other.Element

    /// Returns a new collection of the same type containing, in order, the
    /// elements of the original collection that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned collection.
    /// - Returns: A collection of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @available(swift 4.0)
    @inlinable public func filter(_ isIncluded: (Unicode.Scalar) throws -> Bool) rethrows -> String.UnicodeScalarView

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. The order of the remaining elements is preserved.
    /// This example removes all the vowels from a string:
    ///
    ///     var phrase = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     phrase.removeAll(where: { vowels.contains($0) })
    ///     // phrase == "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter shouldBeRemoved: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public mutating func removeAll(where shouldBeRemoved: (Unicode.Scalar) throws -> Bool) rethrows

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<String.UnicodeScalarView>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (Unicode.Scalar) throws -> T) rethrows -> [T]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (Unicode.Scalar) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Unicode.Scalar?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Unicode.Scalar>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<String.UnicodeScalarView>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (Unicode.Scalar, Unicode.Scalar) throws -> Bool) rethrows -> Unicode.Scalar?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (Unicode.Scalar, Unicode.Scalar) throws -> Bool) rethrows -> Unicode.Scalar?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> Unicode.Scalar?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> Unicode.Scalar?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Unicode.Scalar, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Unicode.Scalar, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Unicode.Scalar == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Unicode.Scalar, Unicode.Scalar) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Unicode.Scalar == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Unicode.Scalar == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: Unicode.Scalar) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Unicode.Scalar) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Unicode.Scalar) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (Unicode.Scalar) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (Unicode.Scalar) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [Unicode.Scalar]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (Unicode.Scalar, Unicode.Scalar) throws -> Bool) rethrows -> [Unicode.Scalar]

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UnicodeScalarView where Prefix : Sequence, Unicode.Scalar == Prefix.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (Unicode.Scalar) throws -> Bool) rethrows -> Substring.UnicodeScalarView

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.Index>] where C : Collection, Unicode.Scalar == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, Unicode.Scalar == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, Unicode.Scalar == C.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - subrange: The range in the collection in which to search for `other`.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, subrange: Range<String.Index>, maxReplacements: Int = .max) -> String.UnicodeScalarView where C : Collection, Replacement : Collection, Unicode.Scalar == C.Element, C.Element == Replacement.Element

    /// Returns a new collection in which all occurrences of a target sequence
    /// are replaced by another collection.
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    /// - Returns: A new collection in which all occurrences of `other` in
    /// `subrange` of the collection are replaced by `replacement`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func replacing<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) -> String.UnicodeScalarView where C : Collection, Replacement : Collection, Unicode.Scalar == C.Element, C.Element == Replacement.Element

    /// Replaces all occurrences of a target sequence with a given collection
    /// - Parameters:
    ///   - other: The sequence to replace.
    ///   - replacement: The new elements to add to the collection.
    ///   - maxReplacements: A number specifying how many occurrences of `other`
    ///   to replace. Default is `Int.max`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func replace<C, Replacement>(_ other: C, with replacement: Replacement, maxReplacements: Int = .max) where C : Collection, Replacement : Collection, Unicode.Scalar == C.Element, C.Element == Replacement.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix(while predicate: (Unicode.Scalar) throws -> Bool) rethrows

    /// Removes the initial elements that satisfy the given predicate from the
    /// start of the sequence.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public mutating func trimPrefix<Prefix>(_ prefix: Prefix) where Prefix : Sequence, Unicode.Scalar == Prefix.Element

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Unicode.Scalar == PossiblePrefix.Element
}

/// Default implementation for forward collections.
extension String.UnicodeScalarView {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout String.Index)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int, limitedBy limit: String.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> Unicode.Scalar? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> Unicode.Scalar?
}

/// Default implementations of core requirements
extension String.UnicodeScalarView {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: Unicode.Scalar? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

extension String.UnicodeScalarView : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// The position of the first Unicode scalar value if the string is
    /// nonempty.
    ///
    /// If the string is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: String.UnicodeScalarView.Index { get }

    /// The "past the end" position---that is, the position one greater than
    /// the last valid subscript argument.
    ///
    /// In an empty Unicode scalars view, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: String.UnicodeScalarView.Index { get }

    /// Returns the next consecutive location after `i`.
    ///
    /// - Precondition: The next location exists.
    @inlinable public func index(after i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

    /// Returns the previous consecutive location before `i`.
    ///
    /// - Precondition: The previous location exists.
    @inlinable public func index(before i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

    /// Accesses the Unicode scalar value at the given position.
    ///
    /// The following example searches a string's Unicode scalars view for a
    /// capital letter and then prints the character and Unicode scalar value
    /// at the found index:
    ///
    ///     let greeting = "Hello, friend!"
    ///     if let i = greeting.unicodeScalars.firstIndex(where: { "A"..."Z" ~= $0 }) {
    ///         print("First capital letter: \(greeting.unicodeScalars[i])")
    ///         print("Unicode scalar value: \(greeting.unicodeScalars[i].value)")
    ///     }
    ///     // Prints "First capital letter: H"
    ///     // Prints "Unicode scalar value: 72"
    ///
    /// - Parameter position: A valid index of the character view. `position`
    ///   must be less than the view's end index.
    @inlinable public subscript(position: String.UnicodeScalarView.Index) -> Unicode.Scalar { get }

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: String.UnicodeScalarView.Index, to end: String.UnicodeScalarView.Index) -> Int

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: String.UnicodeScalarView.Index, offsetBy distance: Int) -> String.UnicodeScalarView.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: String.UnicodeScalarView.Index, offsetBy distance: Int, limitedBy limit: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index?

    /// A type representing the sequence's elements.
    public typealias Element = Unicode.Scalar

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<String.UnicodeScalarView>
}

extension String.UnicodeScalarView : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension String.UnicodeScalarView : RangeReplaceableCollection {

    /// Creates an empty view instance.
    @inlinable public init()

    /// Reserves enough space in the view's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because a Unicode scalar value can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding to a Unicode scalar view after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*), where *n* is the capacity being reserved.
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given Unicode scalar to the view.
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ c: Unicode.Scalar)

    /// Appends the Unicode scalar values in the given sequence to the view.
    ///
    /// - Parameter newElements: A sequence of Unicode scalar values.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting view.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == Unicode.Scalar

    /// Replaces the elements within the specified bounds with the given Unicode
    /// scalar values.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - subrange: The range of elements to replace. The bounds of the range
    ///     must be valid indices of the view.
    ///   - newElements: The new Unicode scalar values to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the view and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes elements at the end of the string, the complexity is O(*n*),
    ///   where *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C>(_ subrange: Range<String.UnicodeScalarView.Index>, with newElements: C) where C : Collection, C.Element == Unicode.Scalar
}

extension String.UnicodeScalarView : CustomReflectable {

    /// Returns a mirror that reflects the Unicode scalars view of a string.
    public var customMirror: Mirror { get }
}

extension String.UnicodeScalarView : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

/// Default implementation for bidirectional collections.
extension String.UTF8View {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout String.Index)
}

/// Default implementation for forward collections.
extension String.UTF8View {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout String.Index)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout String.Index, offsetBy distance: Int, limitedBy limit: String.Index) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> UTF8.CodeUnit? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> UTF8.CodeUnit?
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension String.UTF8View {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<String.UTF8View>
}

/// Default implementations of core requirements
extension String.UTF8View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: UTF8.CodeUnit? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

extension String.UTF8View {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(swift, deprecated: 4.2, message: "UTF8View.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<String.UTF8View.Element>) throws -> R) rethrows -> R?

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Substring.UTF8View

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Substring.UTF8View

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (UTF8.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Substring.UTF8View

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Substring.UTF8View

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Substring.UTF8View

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Substring.UTF8View

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: String.Index) -> Substring.UTF8View

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: String.Index) -> Substring.UTF8View

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: String.Index) -> Substring.UTF8View

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UTF8.CodeUnit) throws -> Bool) rethrows -> [Substring.UTF8View]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: UTF8.CodeUnit, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Substring.UTF8View]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: UTF8.CodeUnit? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: UTF8.CodeUnit) -> String.Index?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> String.Index?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> String.Index?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: UTF8.CodeUnit) -> String.Index?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [UTF8.CodeUnit] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [UTF8.CodeUnit]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, UTF8.CodeUnit) -> Bool) -> CollectionDifference<UTF8.CodeUnit> where C : BidirectionalCollection, UTF8.CodeUnit == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<UTF8.CodeUnit> where C : BidirectionalCollection, UTF8.CodeUnit == C.Element

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: DefaultIndices<String.UTF8View> { get }

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<String.UTF8View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (UTF8.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: UTF8.CodeUnit) -> String.Index?

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Substring.UTF8View where R : RangeExpression, String.Index == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Substring.UTF8View { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<String.UTF8View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (UTF8.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (UTF8.CodeUnit) throws -> Bool) rethrows -> [UTF8.CodeUnit]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (UTF8.CodeUnit) throws -> Void) rethrows

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, UTF8.CodeUnit == C.Element

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Substring.UTF8View where Prefix : Sequence, UTF8.CodeUnit == Prefix.Element

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<UTF8.CodeUnit>) throws -> R) rethrows -> R?

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> UTF8.CodeUnit?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> UTF8.CodeUnit?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UTF8.CodeUnit, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, UTF8.CodeUnit == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UTF8.CodeUnit, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: UTF8.CodeUnit) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UTF8.CodeUnit) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, UTF8.CodeUnit) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (UTF8.CodeUnit) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (UTF8.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [UTF8.CodeUnit]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> [UTF8.CodeUnit]

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Substring.UTF8View

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<String.Index>] where C : Collection, UTF8.CodeUnit == C.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<String.Index>? where C : Collection, UTF8.CodeUnit == C.Element

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<String.UTF8View>
}

/// In Swift 3.2, in the absence of type context,
///
///   someString.utf8[someString.utf8.startIndex..<someString.utf8.endIndex]
///
/// was deduced to be of type `String.UTF8View`.  Provide a more-specific
/// Swift-3-only `subscript` overload that continues to produce
/// `String.UTF8View`.
extension String.UTF8View {

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Substring.UTF8View

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @available(swift 4)
    @inlinable public subscript(r: Range<String.UTF8View.Index>) -> String.UTF8View.SubSequence { get }
}

extension String.UTF8View : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

extension String.UTF8View : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension String.UTF8View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-8 view of a string.
    public var customMirror: Mirror { get }
}

extension String.UTF8View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// A type representing the sequence's elements.
    public typealias Element = UTF8.CodeUnit

    /// The position of the first code unit if the UTF-8 view is
    /// nonempty.
    ///
    /// If the UTF-8 view is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: String.UTF8View.Index { get }

    /// The "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// In an empty UTF-8 view, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: String.UTF8View.Index { get }

    /// Returns the next consecutive position after `i`.
    ///
    /// - Precondition: The next position is representable.
    @inlinable public func index(after i: String.UTF8View.Index) -> String.UTF8View.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before i: String.UTF8View.Index) -> String.UTF8View.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: String.UTF8View.Index, offsetBy n: Int) -> String.UTF8View.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func index(_ i: String.UTF8View.Index, offsetBy n: Int, limitedBy limit: String.UTF8View.Index) -> String.UTF8View.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    @inlinable public func distance(from i: String.UTF8View.Index, to j: String.UTF8View.Index) -> Int

    /// Accesses the code unit at the given position.
    ///
    /// The following example uses the subscript to print the value of a
    /// string's first UTF-8 code unit.
    ///
    ///     let greeting = "Hello, friend!"
    ///     let i = greeting.utf8.startIndex
    ///     print("First character's UTF-8 code unit: \(greeting.utf8[i])")
    ///     // Prints "First character's UTF-8 code unit: 72"
    ///
    /// - Parameter position: A valid index of the view. `position`
    ///   must be less than the view's end index.
    @inlinable public subscript(i: String.UTF8View.Index) -> UTF8.CodeUnit { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<String.UTF8View>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<String.UTF8View>
}

/// A string type designed to represent text that is known at compile time.
///
/// Instances of the `StaticString` type are immutable.
///
/// `StaticString` provides only low-level access to its contents, unlike
/// Swift's more commonly used `String` type. A static string can use
/// either of the following as its storage:
///
/// * a pointer to a null-terminated sequence of UTF-8 code units:
///
///       let emoji: StaticString = "\u{1F600}"
///       emoji.hasPointerRepresentation  //-> true
///       emoji.isASCII                   //-> false
///       emoji.unicodeScalar             //-> Fatal error!
///       emoji.utf8CodeUnitCount         //-> 4
///       emoji.utf8Start[0]              //-> 0xF0
///       emoji.utf8Start[1]              //-> 0x9F
///       emoji.utf8Start[2]              //-> 0x98
///       emoji.utf8Start[3]              //-> 0x80
///       emoji.utf8Start[4]              //-> 0x00
///
/// * a single Unicode scalar value, under very limited circumstances:
///
///       struct MyStaticScalar: ExpressibleByUnicodeScalarLiteral {
///           typealias UnicodeScalarLiteralType = StaticString
///           let value: StaticString
///           init(unicodeScalarLiteral value: StaticString) {
///               self.value = value
///           }
///       }
///
///       let emoji: StaticString = MyStaticScalar("\u{1F600}").value
///       emoji.hasPointerRepresentation  //-> false
///       emoji.isASCII                   //-> false
///       emoji.unicodeScalar.value       //-> 0x1F600
///       emoji.utf8CodeUnitCount         //-> Fatal error!
///       emoji.utf8Start                 //-> Fatal error!
///
/// You can use the `withUTF8Buffer(_:)` method to access a static string's
/// contents, regardless of which representation the static string uses.
///
///     emoji.withUTF8Buffer { utf8 in
///         utf8.count  //-> 4
///         utf8[0]     //-> 0xF0
///         utf8[1]     //-> 0x9F
///         utf8[2]     //-> 0x98
///         utf8[3]     //-> 0x80
///         utf8[4]     //-> Fatal error!
///     }
@frozen public struct StaticString : Sendable {

    /// Creates an empty static string.
    public init()

    /// A pointer to a null-terminated sequence of UTF-8 code units.
    ///
    /// - Important: Accessing this property when `hasPointerRepresentation` is
    ///   `false` triggers a runtime error.
    public var utf8Start: UnsafePointer<UInt8> { get }

    /// A single Unicode scalar value.
    ///
    /// - Important: Accessing this property when `hasPointerRepresentation` is
    ///   `true` triggers a runtime error.
    public var unicodeScalar: Unicode.Scalar { get }

    /// The number of UTF-8 code units (excluding the null terminator).
    ///
    /// - Important: Accessing this property when `hasPointerRepresentation` is
    ///   `false` triggers a runtime error.
    public var utf8CodeUnitCount: Int { get }

    /// A Boolean value that indicates whether the static string stores a
    /// pointer to a null-terminated sequence of UTF-8 code units.
    ///
    /// If `hasPointerRepresentation` is `false`, the static string stores a
    /// single Unicode scalar value.
    public var hasPointerRepresentation: Bool { get }

    /// A Boolean value that indicates whether the static string represents only
    /// ASCII code units (or an ASCII scalar value).
    public var isASCII: Bool { get }

    /// Invokes the given closure with a buffer containing the static string's
    /// UTF-8 code unit sequence (excluding the null terminator).
    ///
    /// This method works regardless of whether the static string stores a
    /// pointer or a single Unicode scalar value.
    ///
    /// The pointer argument to `body` is valid only during the execution of
    /// `withUTF8Buffer(_:)`. Do not store or return the pointer for later use.
    ///
    /// - Parameter body: A closure that takes a buffer pointer to the static
    ///   string's UTF-8 code unit sequence as its sole argument. If the closure
    ///   has a return value, that value is also used as the return value of the
    ///   `withUTF8Buffer(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure.
    public func withUTF8Buffer<R>(_ body: (UnsafeBufferPointer<UInt8>) -> R) -> R

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: StaticString)

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral value: StaticString)
}

extension StaticString : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates an instance initialized to a single character that is made up of
    /// one or more Unicode scalar values.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using an extended grapheme cluster.
    public init(extendedGraphemeClusterLiteral value: StaticString)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = StaticString
}

extension StaticString : ExpressibleByUnicodeScalarLiteral {

    /// Creates an instance initialized to a single Unicode scalar.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string with a Unicode scalar.
    public init(unicodeScalarLiteral value: StaticString)

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = StaticString
}

extension StaticString : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the value of a string literal.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using a string literal.
    public init(stringLiteral value: StaticString)

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = StaticString
}

extension StaticString : CustomStringConvertible {

    /// A textual representation of the static string.
    public var description: String { get }
}

extension StaticString : CustomDebugStringConvertible {

    /// A textual representation of the static string, suitable for debugging.
    public var debugDescription: String { get }
}

extension StaticString : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// Represents a string literal with interpolations while it is being built up.
///
/// Do not create an instance of this type directly. It is used by the compiler
/// when you create a string using string interpolation. Instead, use string
/// interpolation to create a new string by including values, literals,
/// variables, or expressions enclosed in parentheses, prefixed by a
/// backslash (`\(`...`)`).
///
///     let price = 2
///     let number = 3
///     let message = """
///                   If one cookie costs \(price) dollars, \
///                   \(number) cookies cost \(price * number) dollars.
///                   """
///     print(message)
///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
///
/// When implementing an `ExpressibleByStringInterpolation` conformance,
/// set the `StringInterpolation` associated type to
/// `DefaultStringInterpolation` to get the same interpolation behavior as
/// Swift's built-in `String` type and construct a `String` with the results.
/// If you don't want the default behavior or don't want to construct a
/// `String`, use a custom type conforming to `StringInterpolationProtocol`
/// instead.
///
/// Extending default string interpolation behavior
/// ===============================================
///
/// Code outside the standard library can extend string interpolation on
/// `String` and many other common types by extending
/// `DefaultStringInterpolation` and adding an `appendInterpolation(...)`
/// method. For example:
///
///     extension DefaultStringInterpolation {
///         fileprivate mutating func appendInterpolation(
///                  escaped value: String, asASCII forceASCII: Bool = false) {
///             for char in value.unicodeScalars {
///                 appendInterpolation(char.escaped(asASCII: forceASCII))
///             }
///         }
///     }
///
///     print("Escaped string: \(escaped: string)")
///
/// See `StringInterpolationProtocol` for details on `appendInterpolation`
/// methods.
///
/// `DefaultStringInterpolation` extensions should add only `mutating` members
/// and should not copy `self` or capture it in an escaping closure.
@frozen public struct DefaultStringInterpolation : StringInterpolationProtocol, Sendable {

    /// Creates a string interpolation with storage pre-sized for a literal
    /// with the indicated attributes.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    @inlinable public init(literalCapacity: Int, interpolationCount: Int)

    /// Appends a literal segment of a string interpolation.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations.
    @inlinable public mutating func appendLiteral(_ literal: String)

    /// Interpolates the given value's textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : CustomStringConvertible, T : TextOutputStreamable

    /// Interpolates the given value's textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = "If one cookie costs \(price) dollars, " +
    ///                   "\(number) cookies cost \(price * number) dollars."
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : TextOutputStreamable

    /// Interpolates the given value's textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public mutating func appendInterpolation<T>(_ value: T) where T : CustomStringConvertible

    /// Interpolates the given value's textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = """
    ///                   If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///                   """
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    @inlinable public mutating func appendInterpolation<T>(_ value: T)

    public mutating func appendInterpolation(_ value: Any.Type)

    /// The type that should be used for literal segments.
    public typealias StringLiteralType = String
}

extension DefaultStringInterpolation : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    @inlinable public var description: String { get }
}

extension DefaultStringInterpolation : TextOutputStream {

    /// Appends the given string to the stream.
    @inlinable public mutating func write(_ string: String)
}

/// The result of one Unicode decoding step.
///
/// Each `UnicodeDecodingResult` instance can represent a Unicode scalar value,
/// an indication that no more Unicode scalars are available, or an indication
/// of a decoding error.
@frozen public enum UnicodeDecodingResult : Equatable, Sendable {

    /// A decoded Unicode scalar value.
    case scalarValue(Unicode.Scalar)

    /// An indication that no more Unicode scalars are available in the input.
    case emptyInput

    /// An indication of a decoding error.
    case error

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: UnicodeDecodingResult, rhs: UnicodeDecodingResult) -> Bool

    public static func != (lhs: UnicodeDecodingResult, rhs: UnicodeDecodingResult) -> Bool
}

/// A Unicode encoding form that translates between Unicode scalar values and
/// form-specific code units.
///
/// The `UnicodeCodec` protocol declares methods that decode code unit
/// sequences into Unicode scalar values and encode Unicode scalar values
/// into code unit sequences. The standard library implements codecs for the
/// UTF-8, UTF-16, and UTF-32 encoding schemes as the `UTF8`, `UTF16`, and
/// `UTF32` types, respectively. Use the `Unicode.Scalar` type to work with
/// decoded Unicode scalar values.
public protocol UnicodeCodec : _UnicodeEncoding {

    /// Creates an instance of the codec.
    init()

    /// Starts or continues decoding a code unit sequence into Unicode scalar
    /// values.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances:
    ///
    ///     let str = "✨Unicode✨"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, Self.CodeUnit == I.Element

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("𝄐") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code uses the `UTF8` codec to encode a
    /// fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("𝄐", into: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Self.CodeUnit) -> Void)
}

/// Translates the given input from one Unicode encoding to another by calling
/// the given closure.
///
/// The following example transcodes the UTF-8 representation of the string
/// `"Fermata 𝄐"` into UTF-32.
///
///     let fermata = "Fermata 𝄐"
///     let bytes = fermata.utf8
///     print(Array(bytes))
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
///
///     var codeUnits: [UTF32.CodeUnit] = []
///     let sink = { codeUnits.append($0) }
///     transcode(bytes.makeIterator(), from: UTF8.self, to: UTF32.self,
///               stoppingOnError: false, into: sink)
///     print(codeUnits)
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 119056]"
///
/// The `sink` closure is called with each resulting UTF-32 code unit as the
/// function iterates over its input.
///
/// - Parameters:
///   - input: An iterator of code units to be translated, encoded as
///     `inputEncoding`. If `stopOnError` is `false`, the entire iterator will
///     be exhausted. Otherwise, iteration will stop if an encoding error is
///     detected.
///   - inputEncoding: The Unicode encoding of `input`.
///   - outputEncoding: The destination Unicode encoding.
///   - stopOnError: Pass `true` to stop translation when an encoding error is
///     detected in `input`. Otherwise, a Unicode replacement character
///     (`"\u{FFFD}"`) is inserted for each detected error.
///   - processCodeUnit: A closure that processes one `outputEncoding` code
///     unit at a time.
/// - Returns: `true` if the translation detected encoding errors in `input`;
///   otherwise, `false`.
@inlinable public func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Void) -> Bool where Input : IteratorProtocol, InputEncoding : _UnicodeEncoding, OutputEncoding : _UnicodeEncoding, Input.Element == InputEncoding.CodeUnit

/// A namespace for Unicode utilities.
@frozen public enum Unicode {

    @frozen public enum ASCII {
    }

    @frozen public enum UTF16 : Sendable {

        case _swift3Buffer(Unicode.UTF16.ForwardParser)
    }

    @frozen public enum UTF32 : Sendable {

        case _swift3Codec

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Unicode.UTF32, b: Unicode.UTF32) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    @frozen public enum UTF8 : Sendable {

        case _swift3Buffer(Unicode.UTF8.ForwardParser)
    }

    public typealias Encoding = _UnicodeEncoding

    /// The result of attempting to parse a `T` from some input.
    @frozen public enum ParseResult<T> {

        /// A `T` was parsed successfully
        case valid(T)

        /// The input was entirely consumed.
        case emptyInput

        /// An encoding error was detected.
        ///
        /// `length` is the number of underlying code units consumed by this
        /// error, guaranteed to be greater than 0.
        case error(length: Int)
    }

    public typealias Parser = _UnicodeParser

    /// A Unicode scalar value.
    ///
    /// The `Unicode.Scalar` type, representing a single Unicode scalar value, is
    /// the element type of a string's `unicodeScalars` collection.
    ///
    /// You can create a `Unicode.Scalar` instance by using a string literal that
    /// contains a single character representing exactly one Unicode scalar value.
    ///
    ///     let letterK: Unicode.Scalar = "K"
    ///     let kim: Unicode.Scalar = "김"
    ///     print(letterK, kim)
    ///     // Prints "K 김"
    ///
    /// You can also create Unicode scalar values directly from their numeric
    /// representation.
    ///
    ///     let airplane = Unicode.Scalar(9992)!
    ///     print(airplane)
    ///     // Prints "✈︎"
    @frozen public struct Scalar : Sendable {
    }

    /// A version of the Unicode Standard represented by its major and minor
    /// components.
    public typealias Version = (major: Int, minor: Int)

    /// The most general classification of a Unicode scalar.
    ///
    /// The general category of a scalar is its "first-order, most usual
    /// categorization". It does not attempt to cover multiple uses of some
    /// scalars, such as the use of letters to represent Roman numerals.
    public enum GeneralCategory : Sendable {

        /// An uppercase letter.
        ///
        /// This value corresponds to the category `Uppercase_Letter` (abbreviated
        /// `Lu`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case uppercaseLetter

        /// A lowercase letter.
        ///
        /// This value corresponds to the category `Lowercase_Letter` (abbreviated
        /// `Ll`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case lowercaseLetter

        /// A digraph character whose first part is uppercase.
        ///
        /// This value corresponds to the category `Titlecase_Letter` (abbreviated
        /// `Lt`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case titlecaseLetter

        /// A modifier letter.
        ///
        /// This value corresponds to the category `Modifier_Letter` (abbreviated
        /// `Lm`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case modifierLetter

        /// Other letters, including syllables and ideographs.
        ///
        /// This value corresponds to the category `Other_Letter` (abbreviated
        /// `Lo`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case otherLetter

        /// A non-spacing combining mark with zero advance width (abbreviated Mn).
        ///
        /// This value corresponds to the category `Nonspacing_Mark` (abbreviated
        /// `Mn`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case nonspacingMark

        /// A spacing combining mark with positive advance width.
        ///
        /// This value corresponds to the category `Spacing_Mark` (abbreviated `Mc`)
        /// in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case spacingMark

        /// An enclosing combining mark.
        ///
        /// This value corresponds to the category `Enclosing_Mark` (abbreviated
        /// `Me`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case enclosingMark

        /// A decimal digit.
        ///
        /// This value corresponds to the category `Decimal_Number` (abbreviated
        /// `Nd`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case decimalNumber

        /// A letter-like numeric character.
        ///
        /// This value corresponds to the category `Letter_Number` (abbreviated
        /// `Nl`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case letterNumber

        /// A numeric character of another type.
        ///
        /// This value corresponds to the category `Other_Number` (abbreviated `No`)
        /// in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case otherNumber

        /// A connecting punctuation mark, like a tie.
        ///
        /// This value corresponds to the category `Connector_Punctuation`
        /// (abbreviated `Pc`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case connectorPunctuation

        /// A dash or hyphen punctuation mark.
        ///
        /// This value corresponds to the category `Dash_Punctuation` (abbreviated
        /// `Pd`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case dashPunctuation

        /// An opening punctuation mark of a pair.
        ///
        /// This value corresponds to the category `Open_Punctuation` (abbreviated
        /// `Ps`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case openPunctuation

        /// A closing punctuation mark of a pair.
        ///
        /// This value corresponds to the category `Close_Punctuation` (abbreviated
        /// `Pe`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case closePunctuation

        /// An initial quotation mark.
        ///
        /// This value corresponds to the category `Initial_Punctuation`
        /// (abbreviated `Pi`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case initialPunctuation

        /// A final quotation mark.
        ///
        /// This value corresponds to the category `Final_Punctuation` (abbreviated
        /// `Pf`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case finalPunctuation

        /// A punctuation mark of another type.
        ///
        /// This value corresponds to the category `Other_Punctuation` (abbreviated
        /// `Po`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case otherPunctuation

        /// A symbol of mathematical use.
        ///
        /// This value corresponds to the category `Math_Symbol` (abbreviated `Sm`)
        /// in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case mathSymbol

        /// A currency sign.
        ///
        /// This value corresponds to the category `Currency_Symbol` (abbreviated
        /// `Sc`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case currencySymbol

        /// A non-letterlike modifier symbol.
        ///
        /// This value corresponds to the category `Modifier_Symbol` (abbreviated
        /// `Sk`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case modifierSymbol

        /// A symbol of another type.
        ///
        /// This value corresponds to the category `Other_Symbol` (abbreviated
        /// `So`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case otherSymbol

        /// A space character of non-zero width.
        ///
        /// This value corresponds to the category `Space_Separator` (abbreviated
        /// `Zs`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case spaceSeparator

        /// A line separator, which is specifically (and only) U+2028 LINE
        /// SEPARATOR.
        ///
        /// This value corresponds to the category `Line_Separator` (abbreviated
        /// `Zl`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case lineSeparator

        /// A paragraph separator, which is specifically (and only) U+2029 PARAGRAPH
        /// SEPARATOR.
        ///
        /// This value corresponds to the category `Paragraph_Separator`
        /// (abbreviated `Zp`) in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case paragraphSeparator

        /// A C0 or C1 control code.
        ///
        /// This value corresponds to the category `Control` (abbreviated `Cc`) in
        /// the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case control

        /// A format control character.
        ///
        /// This value corresponds to the category `Format` (abbreviated `Cf`) in
        /// the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case format

        /// A surrogate code point.
        ///
        /// This value corresponds to the category `Surrogate` (abbreviated `Cs`) in
        /// the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case surrogate

        /// A private-use character.
        ///
        /// This value corresponds to the category `Private_Use` (abbreviated `Co`)
        /// in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case privateUse

        /// A reserved unassigned code point or a non-character.
        ///
        /// This value corresponds to the category `Unassigned` (abbreviated `Cn`)
        /// in the
        /// [Unicode Standard](https://unicode.org/reports/tr44/#General_Category_Values).
        case unassigned

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Unicode.GeneralCategory, b: Unicode.GeneralCategory) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }

    /// The classification of a scalar used in the Canonical Ordering Algorithm
    /// defined by the Unicode Standard.
    ///
    /// Canonical combining classes are used by the ordering algorithm to
    /// determine if two sequences of combining marks should be considered
    /// canonically equivalent (that is, identical in interpretation). Two
    /// sequences are canonically equivalent if they are equal when sorting the
    /// scalars in ascending order by their combining class.
    ///
    /// For example, consider the sequence `"\u{0041}\u{0301}\u{0316}"` (LATIN
    /// CAPITAL LETTER A, COMBINING ACUTE ACCENT, COMBINING GRAVE ACCENT BELOW).
    /// The combining classes of these scalars have the numeric values 0, 230, and
    /// 220, respectively. Sorting these scalars by their combining classes yields
    /// `"\u{0041}\u{0316}\u{0301}"`, so two strings that differ only by the
    /// ordering of those scalars would compare as equal:
    ///
    ///     let aboveBeforeBelow = "\u{0041}\u{0301}\u{0316}"
    ///     let belowBeforeAbove = "\u{0041}\u{0316}\u{0301}"
    ///     print(aboveBeforeBelow == belowBeforeAbove)
    ///     // Prints "true"
    ///
    /// Named and Unnamed Combining Classes
    /// ===================================
    ///
    /// Canonical combining classes are defined in the Unicode Standard as
    /// integers in the range `0...254`. For convenience, the standard assigns
    /// symbolic names to a subset of these combining classes.
    ///
    /// The `CanonicalCombiningClass` type conforms to `RawRepresentable` with a
    /// raw value of type `UInt8`. You can create instances of the type by using
    /// the static members named after the symbolic names, or by using the
    /// `init(rawValue:)` initializer.
    ///
    ///     let overlayClass = Unicode.CanonicalCombiningClass(rawValue: 1)
    ///     let overlayClassIsOverlay = overlayClass == .overlay
    ///     // overlayClassIsOverlay == true
    public struct CanonicalCombiningClass : Comparable, Hashable, RawRepresentable, Sendable {

        /// Base glyphs that occupy their own space and do not combine with others.
        public static let notReordered: Unicode.CanonicalCombiningClass

        /// Marks that overlay a base letter or symbol.
        public static let overlay: Unicode.CanonicalCombiningClass

        /// Diacritic nukta marks in Brahmi-derived scripts.
        public static let nukta: Unicode.CanonicalCombiningClass

        /// Combining marks that are attached to hiragana and katakana to indicate
        /// voicing changes.
        public static let kanaVoicing: Unicode.CanonicalCombiningClass

        /// Diacritic virama marks in Brahmi-derived scripts.
        public static let virama: Unicode.CanonicalCombiningClass

        /// Marks attached at the bottom left.
        public static let attachedBelowLeft: Unicode.CanonicalCombiningClass

        /// Marks attached directly below.
        public static let attachedBelow: Unicode.CanonicalCombiningClass

        /// Marks attached directly above.
        public static let attachedAbove: Unicode.CanonicalCombiningClass

        /// Marks attached at the top right.
        public static let attachedAboveRight: Unicode.CanonicalCombiningClass

        /// Distinct marks at the bottom left.
        public static let belowLeft: Unicode.CanonicalCombiningClass

        /// Distinct marks directly below.
        public static let below: Unicode.CanonicalCombiningClass

        /// Distinct marks at the bottom right.
        public static let belowRight: Unicode.CanonicalCombiningClass

        /// Distinct marks to the left.
        public static let left: Unicode.CanonicalCombiningClass

        /// Distinct marks to the right.
        public static let right: Unicode.CanonicalCombiningClass

        /// Distinct marks at the top left.
        public static let aboveLeft: Unicode.CanonicalCombiningClass

        /// Distinct marks directly above.
        public static let above: Unicode.CanonicalCombiningClass

        /// Distinct marks at the top right.
        public static let aboveRight: Unicode.CanonicalCombiningClass

        /// Distinct marks subtending two bases.
        public static let doubleBelow: Unicode.CanonicalCombiningClass

        /// Distinct marks extending above two bases.
        public static let doubleAbove: Unicode.CanonicalCombiningClass

        /// Greek iota subscript only (U+0345 COMBINING GREEK YPOGEGRAMMENI).
        public static let iotaSubscript: Unicode.CanonicalCombiningClass

        /// The raw integer value of the canonical combining class.
        public let rawValue: UInt8

        /// Creates a new canonical combining class with the given raw integer
        /// value.
        ///
        /// - Parameter rawValue: The raw integer value of the canonical combining
        ///   class.
        public init(rawValue: UInt8)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

        /// Returns a Boolean value indicating whether the value of the first
        /// argument is less than that of the second argument.
        ///
        /// This function is the only requirement of the `Comparable` protocol. The
        /// remainder of the relational operator functions are implemented by the
        /// standard library for any type that conforms to `Comparable`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func < (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = UInt8
    }

    /// The numeric type of a scalar.
    ///
    /// Scalars with a non-nil numeric type include numbers, fractions, numeric
    /// superscripts and subscripts, and circled or otherwise decorated number
    /// glyphs.
    ///
    /// Some letterlike scalars used in numeric systems, such as Greek or Latin
    /// letters, do not have a non-nil numeric type, in order to prevent programs
    /// from incorrectly interpreting them as numbers in non-numeric contexts.
    public enum NumericType : Sendable {

        /// A digit that is commonly understood to form base-10 numbers.
        ///
        /// Specifically, scalars have this numeric type if they occupy a contiguous
        /// range of code points representing numeric values `0...9`.
        case decimal

        /// A digit that does not meet the requirements of the `decimal` numeric
        /// type.
        ///
        /// Scalars with this numeric type are often those that represent a decimal
        /// digit but would not typically be used to write a base-10 number, such
        /// as "④" (U+2463 CIRCLED DIGIT FOUR).
        ///
        /// As of Unicode 6.3, any new scalars that represent numbers but do not
        /// meet the requirements of `decimal` will have numeric type `numeric`,
        /// and programs can treat `digit` and `numeric` equivalently.
        case digit

        /// A digit that does not meet the requirements of the `decimal` numeric
        /// type or a non-digit numeric value.
        ///
        /// This numeric type includes fractions such as "⅕" (U+2155 VULGAR
        /// FRACTION ONE FIFTH), numerical CJK ideographs like "兆" (U+5146 CJK
        /// UNIFIED IDEOGRAPH-5146), and other scalars that are not decimal digits
        /// used positionally in the writing of base-10 numbers.
        ///
        /// As of Unicode 6.3, any new scalars that represent numbers but do not
        /// meet the requirements of `decimal` will have numeric type `numeric`,
        /// and programs can treat `digit` and `numeric` equivalently.
        case numeric

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Unicode.NumericType, b: Unicode.NumericType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }
    }
}

extension Unicode.ASCII {

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> CollectionOfOne<CodeUnit>? where FromEncoding : _UnicodeEncoding
}

extension Unicode.ASCII : Unicode.Encoding {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt8

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar = CollectionOfOne<Unicode.ASCII.CodeUnit>

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    @inlinable public static var encodedReplacementCharacter: Unicode.ASCII.EncodedScalar { get }

    /// Returns whether the given code unit represents an ASCII scalar
    public static func isASCII(_ x: Unicode.ASCII.CodeUnit) -> Bool

    /// Converts from encoded to encoding-independent representation
    @inlinable public static func decode(_ source: Unicode.ASCII.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    @inlinable public static func encode(_ source: Unicode.Scalar) -> Unicode.ASCII.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.ASCII.EncodedScalar? where FromEncoding : _UnicodeEncoding

    @frozen public struct Parser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public typealias ForwardParser = Unicode.ASCII.Parser

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public typealias ReverseParser = Unicode.ASCII.Parser
}

extension Unicode.Scalar {

    /// A custom playground Quick Look for the `Unicode.Scalar` instance.
    @available(*, deprecated, message: "Unicode.Scalar.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: _PlaygroundQuickLook { get }

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. `v` must be
    ///   a valid Unicode scalar value, in the ranges `0...0xD7FF` or
    ///   `0xE000...0x10FFFF`. In case of an invalid unicode scalar value, nil is
    ///   returned.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar` instance
    /// with a value of an emoji character:
    ///
    ///     let codepoint = 127881
    ///     let emoji = Unicode.Scalar(codepoint)!
    ///     print(emoji)
    ///     // Prints "🎉"
    ///
    /// In case of an invalid input value, nil is returned.
    ///
    ///     let codepoint: UInt32 = extValue // This might be an invalid value.
    ///     if let emoji = Unicode.Scalar(codepoint) {
    ///       print(emoji)
    ///     } else {
    ///       // Do something else
    ///     }
    @inlinable public init?(_ v: Int)

    @frozen public struct UTF16View : Sendable {
    }

    @inlinable public var utf16: Unicode.Scalar.UTF16View { get }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @frozen public struct UTF8View : Sendable {
    }

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    @inlinable public var utf8: Unicode.Scalar.UTF8View { get }

    /// A value that provides access to properties of a Unicode scalar that are
    /// defined by the Unicode standard.
    public struct Properties : Sendable {
    }

    /// Properties of this scalar defined by the Unicode standard.
    ///
    /// Use this property to access the Unicode properties of a Unicode scalar
    /// value. The following code tests whether a string contains any math
    /// symbols:
    ///
    ///     let question = "Which is larger, 3 * 3 * 3 or 10 + 10 + 10?"
    ///     let hasMathSymbols = question.unicodeScalars.contains(where: {
    ///         $0.properties.isMath
    ///     })
    ///     // hasMathSymbols == true
    public var properties: Unicode.Scalar.Properties { get }

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: Unicode.Scalar, maximum: Unicode.Scalar) -> ClosedRange<Unicode.Scalar>

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool

    public static func != (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: Unicode.Scalar, maximum: Unicode.Scalar) -> Range<Unicode.Scalar>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: Unicode.Scalar) -> PartialRangeUpTo<Unicode.Scalar>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: Unicode.Scalar) -> PartialRangeThrough<Unicode.Scalar>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: Unicode.Scalar) -> PartialRangeFrom<Unicode.Scalar>
}

extension Unicode.Scalar : ExpressibleByUnicodeScalarLiteral {

    /// A numeric representation of the Unicode scalar.
    @inlinable public var value: UInt32 { get }

    /// Creates a Unicode scalar with the specified value.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you use a string literal to initialize a `Unicode.Scalar` instance.
    ///
    ///     let letterK: Unicode.Scalar = "K"
    ///     print(letterK)
    ///     // Prints "K"
    ///
    /// In this example, the assignment to the `letterK` constant is handled by
    /// this initializer behind the scenes.
    public init(unicodeScalarLiteral value: Unicode.Scalar)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of an emoji character:
    ///
    ///     let codepoint: UInt32 = 127881
    ///     let emoji = Unicode.Scalar(codepoint)
    ///     print(emoji!)
    ///     // Prints "🎉"
    ///
    /// In case of an invalid input value, nil is returned.
    ///
    ///     let codepoint: UInt32 = extValue   // This might be an invalid value
    ///     if let emoji = Unicode.Scalar(codepoint) {
    ///       print(emoji)
    ///     } else {
    ///       // Do something else
    ///     }
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. The
    ///   initializer succeeds if `v` is a valid Unicode scalar value---that is,
    ///   if `v` is in the range `0...0xD7FF` or `0xE000...0x10FFFF`. If `v` is
    ///   an invalid Unicode scalar value, the result is `nil`.
    @inlinable public init?(_ v: UInt32)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of `"밥"`, the Korean word for rice:
    ///
    ///     let codepoint: UInt16 = 48165
    ///     let bap = Unicode.Scalar(codepoint)
    ///     print(bap!)
    ///     // Prints "밥"
    ///
    /// In case of an invalid input value, the result is `nil`.
    ///
    ///     let codepoint: UInt16 = extValue   // This might be an invalid value
    ///     if let bap = Unicode.Scalar(codepoint) {
    ///         print(bap)
    ///     } else {
    ///         // Do something else
    ///     }
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. The
    ///   initializer succeeds if `v` is a valid Unicode scalar value, in the
    ///   range `0...0xD7FF` or `0xE000...0x10FFFF`. If `v` is an invalid
    ///   unicode scalar value, the result is `nil`.
    @inlinable public init?(_ v: UInt16)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of `"7"`:
    ///
    ///     let codepoint: UInt8 = 55
    ///     let seven = Unicode.Scalar(codepoint)
    ///     print(seven)
    ///     // Prints "7"
    ///
    /// - Parameter v: The code point to use for the scalar.
    @inlinable public init(_ v: UInt8)

    /// Creates a duplicate of the given Unicode scalar.
    @inlinable public init(_ v: Unicode.Scalar)

    /// Returns a string representation of the Unicode scalar.
    ///
    /// Scalar values representing characters that are normally unprintable or
    /// that otherwise require escaping are escaped with a backslash.
    ///
    ///     let tab = Unicode.Scalar(9)!
    ///     print(tab)
    ///     // Prints " "
    ///     print(tab.escaped(asASCII: false))
    ///     // Prints "\t"
    ///
    /// When the `forceASCII` parameter is `true`, a `Unicode.Scalar` instance
    /// with a value greater than 127 is represented using an escaped numeric
    /// value; otherwise, non-ASCII characters are represented using their
    /// typical string value.
    ///
    ///     let bap = Unicode.Scalar(48165)!
    ///     print(bap.escaped(asASCII: false))
    ///     // Prints "밥"
    ///     print(bap.escaped(asASCII: true))
    ///     // Prints "\u{BC25}"
    ///
    /// - Parameter forceASCII: Pass `true` if you need the result to use only
    ///   ASCII characters; otherwise, pass `false`.
    /// - Returns: A string representation of the scalar.
    public func escaped(asASCII forceASCII: Bool) -> String

    /// A Boolean value indicating whether the Unicode scalar is an ASCII
    /// character.
    ///
    /// ASCII characters have a scalar value between 0 and 127, inclusive. For
    /// example:
    ///
    ///     let canyon = "Cañón"
    ///     for scalar in canyon.unicodeScalars {
    ///         print(scalar, scalar.isASCII, scalar.value)
    ///     }
    ///     // Prints "C true 67"
    ///     // Prints "a true 97"
    ///     // Prints "ñ false 241"
    ///     // Prints "ó false 243"
    ///     // Prints "n true 110"
    @inlinable public var isASCII: Bool { get }

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = Unicode.Scalar
}

extension Unicode.Scalar : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    @inlinable public init?(_ description: String)
}

extension Unicode.Scalar : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @inlinable public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

extension Unicode.Scalar : TextOutputStreamable {

    /// Writes the textual representation of the Unicode scalar into the given
    /// output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension Unicode.Scalar : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool
}

extension Unicode.Scalar : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool
}

extension Unicode.Scalar : CustomReflectable {

    /// A mirror that reflects the `Unicode.Scalar` instance.
    public var customMirror: Mirror { get }
}

extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the Unicode scalar.
    @inlinable public var description: String { get }

    /// An escaped textual representation of the Unicode scalar, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Unicode.UTF16 {

    /// Returns the number of code units required to encode the given Unicode
    /// scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let anA: Unicode.Scalar = "A"
    ///     print(anA.value)
    ///     // Prints "65"
    ///     print(UTF16.width(anA))
    ///     // Prints "1"
    ///
    ///     let anApple: Unicode.Scalar = "🍎"
    ///     print(anApple.value)
    ///     // Prints "127822"
    ///     print(UTF16.width(anApple))
    ///     // Prints "2"
    ///
    /// - Parameter x: A Unicode scalar value.
    /// - Returns: The width of `x` when encoded in UTF-16, either `1` or `2`.
    @inlinable public static func width(_ x: Unicode.Scalar) -> Int

    /// Returns the high-surrogate code unit of the surrogate pair representing
    /// the specified Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: Unicode.Scalar = "🍎"
    ///     print(UTF16.leadSurrogate(apple))
    ///     // Prints "55356"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The leading surrogate code unit of `x` when encoded in UTF-16.
    @inlinable public static func leadSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit

    /// Returns the low-surrogate code unit of the surrogate pair representing
    /// the specified Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: Unicode.Scalar = "🍎"
    ///     print(UTF16.trailSurrogate(apple))
    ///     // Prints "57166"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The trailing surrogate code unit of `x` when encoded in UTF-16.
    @inlinable public static func trailSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// high-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a lead surrogate. The `apple` string contains a single
    /// emoji character made up of a surrogate pair when encoded in UTF-16.
    ///
    ///     let apple = "🍎"
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isLeadSurrogate(unit))
    ///     }
    ///     // Prints "true"
    ///     // Prints "false"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// low-surrogate code unit follows `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a high-surrogate code unit; otherwise,
    ///   `false`.
    @inlinable public static func isLeadSurrogate(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// low-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a trailing surrogate. The `apple` string contains a
    /// single emoji character made up of a surrogate pair when encoded in
    /// UTF-16.
    ///
    ///     let apple = "🍎"
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isTrailSurrogate(unit))
    ///     }
    ///     // Prints "false"
    ///     // Prints "true"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// high-surrogate code unit precedes `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a low-surrogate code unit; otherwise,
    ///   `false`.
    @inlinable public static func isTrailSurrogate(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// high or low surrogate code unit.
    public static func isSurrogate(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Returns the number of UTF-16 code units required for the given code unit
    /// sequence when transcoded to UTF-16, and a Boolean value indicating
    /// whether the sequence was found to contain only ASCII characters.
    ///
    /// The following example finds the length of the UTF-16 encoding of the
    /// string `"Fermata 𝄐"`, starting with its UTF-8 representation.
    ///
    ///     let fermata = "Fermata 𝄐"
    ///     let bytes = fermata.utf8
    ///     print(Array(bytes))
    ///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
    ///
    ///     let result = UTF16.transcodedLength(of: bytes.makeIterator(),
    ///                                         decodedAs: UTF8.self,
    ///                                         repairingIllFormedSequences: false)
    ///     print(result)
    ///     // Prints "Optional((count: 10, isASCII: false))"
    ///
    /// - Parameters:
    ///   - input: An iterator of code units to be translated, encoded as
    ///     `sourceEncoding`. If `repairingIllFormedSequences` is `true`, the
    ///     entire iterator will be exhausted. Otherwise, iteration will stop if
    ///     an ill-formed sequence is detected.
    ///   - sourceEncoding: The Unicode encoding of `input`.
    ///   - repairingIllFormedSequences: Pass `true` to measure the length of
    ///     `input` even when `input` contains ill-formed sequences. Each
    ///     ill-formed sequence is replaced with a Unicode replacement character
    ///     (`"\u{FFFD}"`) and is measured as such. Pass `false` to immediately
    ///     stop measuring `input` when an ill-formed sequence is encountered.
    /// - Returns: A tuple containing the number of UTF-16 code units required to
    ///   encode `input` and a Boolean value that indicates whether the `input`
    ///   contained only ASCII characters. If `repairingIllFormedSequences` is
    ///   `false` and an ill-formed sequence is detected, this method returns
    ///   `nil`.
    @inlinable public static func transcodedLength<Input, Encoding>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Bool) -> (count: Int, isASCII: Bool)? where Input : IteratorProtocol, Encoding : _UnicodeEncoding, Input.Element == Encoding.CodeUnit

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> _UIntBuffer<UInt16>? where FromEncoding : _UnicodeEncoding
}

extension Unicode.UTF16 : Unicode.Encoding {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt16

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    @inlinable public static var encodedReplacementCharacter: Unicode.UTF16.EncodedScalar { get }

    /// Returns whether the given code unit represents an ASCII scalar
    public static func isASCII(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Converts from encoded to encoding-independent representation
    @inlinable public static func decode(_ source: Unicode.UTF16.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    @inlinable public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF16.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.UTF16.EncodedScalar? where FromEncoding : _UnicodeEncoding

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    @frozen public struct ForwardParser : Sendable {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    @frozen public struct ReverseParser : Sendable {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }
}

/// A codec for translating between Unicode scalar values and UTF-16 code
/// units.
extension Unicode.UTF16 : UnicodeCodec {

    /// Creates an instance of the UTF-16 codec.
    @inlinable public init()

    /// Starts or continues decoding a UTF-16 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "✨Unicode✨"
    ///     print(Array(str.utf16))
    ///     // Prints "[10024, 85, 110, 105, 99, 111, 100, 101, 10024]"
    ///
    ///     var codeUnitIterator = str.utf16.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf16Decoder = UTF16()
    ///     Decode: while true {
    ///         switch utf16Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    @inlinable public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == UInt16

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("𝄐") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires two code units for its UTF-16
    /// representation. The following code encodes a fermata in UTF-16:
    ///
    ///     var codeUnits: [UTF16.CodeUnit] = []
    ///     UTF16.encode("𝄐", into: { codeUnits.append($0) })
    ///     print(codeUnits)
    ///     // Prints "[55348, 56592]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    @inlinable public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF16.CodeUnit) -> Void)
}

extension Unicode.GeneralCategory {

    public static func != (lhs: Unicode.GeneralCategory, rhs: Unicode.GeneralCategory) -> Bool
}

extension Unicode.CanonicalCombiningClass {

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ... (minimum: Unicode.CanonicalCombiningClass, maximum: Unicode.CanonicalCombiningClass) -> ClosedRange<Unicode.CanonicalCombiningClass>

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func > (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func <= (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    @inlinable public static func >= (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

    @inlinable public var hashValue: Int { get }

    public static func != (lhs: Unicode.CanonicalCombiningClass, rhs: Unicode.CanonicalCombiningClass) -> Bool

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    ///
    /// - Precondition: `minimum <= maximum`.
    public static func ..< (minimum: Unicode.CanonicalCombiningClass, maximum: Unicode.CanonicalCombiningClass) -> Range<Unicode.CanonicalCombiningClass>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ..< (maximum: Unicode.CanonicalCombiningClass) -> PartialRangeUpTo<Unicode.CanonicalCombiningClass>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    ///
    /// - Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).
    prefix public static func ... (maximum: Unicode.CanonicalCombiningClass) -> PartialRangeThrough<Unicode.CanonicalCombiningClass>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    ///
    /// - Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).
    postfix public static func ... (minimum: Unicode.CanonicalCombiningClass) -> PartialRangeFrom<Unicode.CanonicalCombiningClass>
}

extension Unicode.NumericType {

    public static func != (lhs: Unicode.NumericType, rhs: Unicode.NumericType) -> Bool
}

extension Unicode.UTF8 {

    /// Returns the number of code units required to encode the given Unicode
    /// scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-8 by a sequence of up
    /// to 4 code units. The first code unit is designated a *lead* byte and the
    /// rest are *continuation* bytes.
    ///
    ///     let anA: Unicode.Scalar = "A"
    ///     print(anA.value)
    ///     // Prints "65"
    ///     print(UTF8.width(anA))
    ///     // Prints "1"
    ///
    ///     let anApple: Unicode.Scalar = "🍎"
    ///     print(anApple.value)
    ///     // Prints "127822"
    ///     print(UTF8.width(anApple))
    ///     // Prints "4"
    ///
    /// - Parameter x: A Unicode scalar value.
    /// - Returns: The width of `x` when encoded in UTF-8, from `1` to `4`.
    public static func width(_ x: Unicode.Scalar) -> Int

    /// The basic unit of encoding
    public typealias CodeUnit = UInt8

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    @inlinable public static var encodedReplacementCharacter: Unicode.UTF8.EncodedScalar { get }

    /// Returns whether the given code unit represents an ASCII scalar
    public static func isASCII(_ x: Unicode.UTF8.CodeUnit) -> Bool

    /// Converts from encoded to encoding-independent representation
    @inlinable public static func decode(_ source: Unicode.UTF8.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    @inlinable public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF8.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.UTF8.EncodedScalar? where FromEncoding : _UnicodeEncoding

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    @frozen public struct ForwardParser : Sendable {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    @frozen public struct ReverseParser : Sendable {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> _ValidUTF8Buffer? where FromEncoding : _UnicodeEncoding
}

/// A codec for translating between Unicode scalar values and UTF-8 code
/// units.
extension Unicode.UTF8 : UnicodeCodec {

    /// Creates an instance of the UTF-8 codec.
    @inlinable public init()

    /// Starts or continues decoding a UTF-8 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "✨Unicode✨"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    @inlinable public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == UInt8

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("𝄐") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code encodes a fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("𝄐", into: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    @inlinable public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF8.CodeUnit) -> Void)

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// UTF-8 continuation byte.
    ///
    /// Continuation bytes take the form `0b10xxxxxx`. For example, a lowercase
    /// "e" with an acute accent above it (`"é"`) uses 2 bytes for its UTF-8
    /// representation: `0b11000011` (195) and `0b10101001` (169). The second
    /// byte is a continuation byte.
    ///
    ///     let eAcute = "é"
    ///     for codeUnit in eAcute.utf8 {
    ///         print(codeUnit, UTF8.isContinuation(codeUnit))
    ///     }
    ///     // Prints "195 false"
    ///     // Prints "169 true"
    ///
    /// - Parameter byte: A UTF-8 code unit.
    /// - Returns: `true` if `byte` is a continuation byte; otherwise, `false`.
    @inlinable public static func isContinuation(_ byte: Unicode.UTF8.CodeUnit) -> Bool
}

extension Unicode.UTF32 {

    public static func != (lhs: Unicode.UTF32, rhs: Unicode.UTF32) -> Bool

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided
    /// automatically for any conforming type that does not implement one.
    @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> CollectionOfOne<UInt32>? where FromEncoding : _UnicodeEncoding
}

extension Unicode.UTF32 : Unicode.Encoding {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt32

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar = CollectionOfOne<UInt32>

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    @inlinable public static var encodedReplacementCharacter: Unicode.UTF32.EncodedScalar { get }

    /// Returns whether the given code unit represents an ASCII scalar
    public static func isASCII(_ x: Unicode.UTF32.CodeUnit) -> Bool

    /// Converts from encoded to encoding-independent representation
    @inlinable public static func decode(_ source: Unicode.UTF32.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    @inlinable public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF32.EncodedScalar?

    @frozen public struct Parser : Sendable {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        @inlinable public init()
    }

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public typealias ForwardParser = Unicode.UTF32.Parser

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public typealias ReverseParser = Unicode.UTF32.Parser
}

/// A codec for translating between Unicode scalar values and UTF-32 code
/// units.
extension Unicode.UTF32 : UnicodeCodec {

    /// Creates an instance of the UTF-32 codec.
    @inlinable public init()

    /// Starts or continues decoding a UTF-32 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string
    /// into an array of `Unicode.Scalar` instances. This is a demonstration
    /// only---if you need the Unicode scalar representation of a string, use
    /// its `unicodeScalars` view.
    ///
    ///     // UTF-32 representation of "✨Unicode✨"
    ///     let codeUnits: [UTF32.CodeUnit] =
    ///             [10024, 85, 110, 105, 99, 111, 100, 101, 10024]
    ///
    ///     var codeUnitIterator = codeUnits.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf32Decoder = UTF32()
    ///     Decode: while true {
    ///         switch utf32Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    @inlinable public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == UInt32

    /// Encodes a Unicode scalar as a UTF-32 code unit by calling the given
    /// closure.
    ///
    /// For example, like every Unicode scalar, the musical fermata symbol ("𝄐")
    /// can be represented in UTF-32 as a single code unit. The following code
    /// encodes a fermata in UTF-32:
    ///
    ///     var codeUnit: UTF32.CodeUnit = 0
    ///     UTF32.encode("𝄐", into: { codeUnit = $0 })
    ///     print(codeUnit)
    ///     // Prints "119056"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    @inlinable public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF32.CodeUnit) -> Void)
}

extension Unicode.ASCII.Parser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.ASCII

    /// Parses a single Unicode scalar value from `input`.
    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Unicode.ASCII.Parser.Encoding.EncodedScalar> where I : IteratorProtocol, I.Element == UInt8
}

/// Default implementation for forward collections.
extension Unicode.Scalar.UTF16View {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Int)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Int, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Int, offsetBy distance: Int, limitedBy limit: Int) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> UTF16.CodeUnit? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> UTF16.CodeUnit?
}

/// Default implementation for random access collections.
extension Unicode.Scalar.UTF16View {

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - distance: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, `limit` should be greater than `i` to have any
    ///     effect. Likewise, if `distance < 0`, `limit` should be less than `i`
    ///     to have any effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?
}

/// Default implementation for bidirectional collections.
extension Unicode.Scalar.UTF16View {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Int)
}

extension Unicode.Scalar.UTF16View {

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (UTF16.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: Int) -> Slice<Unicode.Scalar.UTF16View>

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UTF16.CodeUnit) throws -> Bool) rethrows -> [Slice<Unicode.Scalar.UTF16View>]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: UTF16.CodeUnit, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Slice<Unicode.Scalar.UTF16View>]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: UTF16.CodeUnit? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: UTF16.CodeUnit) -> Int?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Int?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Int?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: UTF16.CodeUnit) -> Int?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [UTF16.CodeUnit] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [UTF16.CodeUnit]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, UTF16.CodeUnit) -> Bool) -> CollectionDifference<UTF16.CodeUnit> where C : BidirectionalCollection, UTF16.CodeUnit == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<UTF16.CodeUnit> where C : BidirectionalCollection, UTF16.CodeUnit == C.Element

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Unicode.Scalar.UTF16View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (UTF16.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: UTF16.CodeUnit) -> Int?

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Int>? where C : Collection, UTF16.CodeUnit == C.Element

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<Int>] where C : Collection, UTF16.CodeUnit == C.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF16View>

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Slice<Unicode.Scalar.UTF16View> where Prefix : Sequence, UTF16.CodeUnit == Prefix.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Int>? where C : Collection, UTF16.CodeUnit == C.Element

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Slice<Unicode.Scalar.UTF16View> where R : RangeExpression, Int == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Slice<Unicode.Scalar.UTF16View> { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Unicode.Scalar.UTF16View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (UTF16.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (UTF16.CodeUnit) throws -> Bool) rethrows -> [UTF16.CodeUnit]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (UTF16.CodeUnit) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<UTF16.CodeUnit>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Unicode.Scalar.UTF16View>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> UTF16.CodeUnit?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> UTF16.CodeUnit?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> UTF16.CodeUnit?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UTF16.CodeUnit, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, UTF16.CodeUnit == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UTF16.CodeUnit, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF16.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (UTF16.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: UTF16.CodeUnit) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UTF16.CodeUnit) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, UTF16.CodeUnit) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (UTF16.CodeUnit) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (UTF16.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [UTF16.CodeUnit]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (UTF16.CodeUnit, UTF16.CodeUnit) throws -> Bool) rethrows -> [UTF16.CodeUnit]
}

/// Default implementations of core requirements
extension Unicode.Scalar.UTF16View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: UTF16.CodeUnit? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Unicode.Scalar.UTF16View {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Unicode.Scalar.UTF16View>
}

/// Supply the default "slicing" `subscript` for `Collection` models
/// that accept the default associated `SubSequence`, `Slice<Self>`.
extension Unicode.Scalar.UTF16View {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(bounds: Range<Int>) -> Slice<Unicode.Scalar.UTF16View> { get }
}

extension Unicode.Scalar.UTF16View : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The position of the first code unit.
    @inlinable public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Int { get }

    /// Accesses the code unit at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    @inlinable public subscript(position: Int) -> UTF16.CodeUnit { get }

    /// A type representing the sequence's elements.
    public typealias Element = UTF16.CodeUnit

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Unicode.Scalar.UTF16View>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<Unicode.Scalar.UTF16View>
}

/// Default implementation for forward collections.
extension Unicode.Scalar.UTF8View {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    @inlinable public func formIndex(after i: inout Int)

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Int, offsetBy distance: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: `true` if `i` has been offset by exactly `distance` steps
    ///   without going beyond `limit`; otherwise, `false`. When the return
    ///   value is `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    @inlinable public func formIndex(_ i: inout Int, offsetBy distance: Int, limitedBy limit: Int) -> Bool

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing a
    ///   random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    /// - Note: The algorithm used to select a random element may change in a
    ///   future version of Swift. If you're passing a generator that results in
    ///   the same sequence of elements each time you run your program, that
    ///   sequence may change when your program is compiled using a different
    ///   version of Swift.
    @inlinable public func randomElement<T>(using generator: inout T) -> UTF8.CodeUnit? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method is equivalent to calling `randomElement(using:)`, passing in
    /// the system's default random generator.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public func randomElement() -> UTF8.CodeUnit?
}

/// Default implementation for random access collections.
extension Unicode.Scalar.UTF8View {

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - distance: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, `limit` should be greater than `i` to have any
    ///     effect. Likewise, if `distance < 0`, `limit` should be less than `i`
    ///     to have any effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1)
    @inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int?
}

/// Default implementation for bidirectional collections.
extension Unicode.Scalar.UTF8View {

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    @inlinable public func formIndex(before i: inout Int)
}

extension Unicode.Scalar.UTF8View {

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop off the end of the
    ///   collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `k` elements from the end.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop.
    @inlinable public func dropLast(_ k: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is equal to
    ///   `maxLength`.
    @inlinable public func suffix(_ maxLength: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    @inlinable public func map<T>(_ transform: (UTF8.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter k: The number of elements to drop from the beginning of
    ///   the collection. `k` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to drop from the beginning of the collection.
    @inlinable public func dropFirst(_ k: Int = 1) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func drop(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
    ///   elements to select from the beginning of the collection.
    @inlinable public func prefix(_ maxLength: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func prefix(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(upTo end: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    @inlinable public func suffix(from start: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// specified by the `through` parameter.
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter position: The index of the last element to include in the
    ///   resulting subsequence. `position` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the given position.
    ///
    /// - Complexity: O(1)
    @inlinable public func prefix(through position: Int) -> Slice<Unicode.Scalar.UTF8View>

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (UTF8.CodeUnit) throws -> Bool) rethrows -> [Slice<Unicode.Scalar.UTF8View>]

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func split(separator: UTF8.CodeUnit, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Slice<Unicode.Scalar.UTF8View>]

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///
    /// - Complexity: O(1)
    @inlinable public var last: UTF8.CodeUnit? { get }

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(of element: UTF8.CodeUnit) -> Int?

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func firstIndex(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Int?

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(lastNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func last(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter *A:*
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Int?

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, this method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    @inlinable public func lastIndex(of element: UTF8.CodeUnit) -> Int?

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you are
    /// using a custom random number generator. For example, you can shuffle the
    /// numbers between `0` and `9` by calling the `shuffled(using:)` method on
    /// that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    /// - Note: The algorithm used to shuffle a sequence may change in a future
    ///   version of Swift. If you're passing a generator that results in the
    ///   same shuffled order each time you run your program, that sequence may
    ///   change when your program is compiled using a different version of
    ///   Swift.
    @inlinable public func shuffled<T>(using generator: inout T) -> [UTF8.CodeUnit] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method is equivalent to calling `shuffled(using:)`, passing in the
    /// system's default random generator.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func shuffled() -> [UTF8.CodeUnit]

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection, using the given predicate as an
    /// equivalence test.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///   - areEquivalent: A closure that returns a Boolean value indicating
    ///     whether two elements are equivalent.
    ///
    /// - Returns: The difference needed to produce the receiver's state from
    ///   the parameter's state.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C, by areEquivalent: (C.Element, UTF8.CodeUnit) -> Bool) -> CollectionDifference<UTF8.CodeUnit> where C : BidirectionalCollection, UTF8.CodeUnit == C.Element

    /// Returns the difference needed to produce this collection's ordered
    /// elements from the given collection.
    ///
    /// This function does not infer element moves. If you need to infer moves,
    /// call the `inferringMoves()` method on the resulting difference.
    ///
    /// - Parameters:
    ///   - other: The base state.
    ///
    /// - Returns: The difference needed to produce this collection's ordered
    ///   elements from the given collection.
    ///
    /// - Complexity: Worst case performance is O(*n* * *m*), where *n* is the
    ///   count of this collection and *m* is `other.count`. You can expect
    ///   faster execution when the collections share many common elements, or
    ///   if `Element` conforms to `Hashable`.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public func difference<C>(from other: C) -> CollectionDifference<UTF8.CodeUnit> where C : BidirectionalCollection, UTF8.CodeUnit == C.Element

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    @inlinable public var lazy: LazySequence<Unicode.Scalar.UTF8View> { get }

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (UTF8.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the first index where the specified value appears in the
    /// collection.
    @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
    @inlinable public func index(of element: UTF8.CodeUnit) -> Int?

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns nil if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Int>? where C : Collection, UTF8.CodeUnit == C.Element

    /// Finds and returns the ranges of the all occurrences of a given sequence
    /// within the collection.
    /// - Parameter other: The sequence to search for.
    /// - Returns: A collection of ranges of all occurrences of `other`. Returns
    ///  an empty collection if `other` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func ranges<C>(of other: C) -> [Range<Int>] where C : Collection, UTF8.CodeUnit == C.Element

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix(while predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Slice<Unicode.Scalar.UTF8View>

    /// Returns a new collection of the same type by removing initial elements
    /// that satisfy the given predicate from the start.
    /// - Parameter predicate: A closure that takes an element of the sequence
    /// as its argument and returns a Boolean value indicating whether the
    /// element should be removed from the collection.
    /// - Returns: A collection containing the elements of the collection that are
    ///  not removed by `predicate`.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func trimmingPrefix<Prefix>(_ prefix: Prefix) -> Slice<Unicode.Scalar.UTF8View> where Prefix : Sequence, UTF8.CodeUnit == Prefix.Element

    /// Finds and returns the range of the first occurrence of a given collection
    /// within this collection.
    ///
    /// - Parameter other: The collection to search for.
    /// - Returns: A range in the collection of the first occurrence of `sequence`.
    /// Returns `nil` if `sequence` is not found.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func firstRange<C>(of other: C) -> Range<Int>? where C : Collection, UTF8.CodeUnit == C.Element

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript<R>(r: R) -> Slice<Unicode.Scalar.UTF8View> where R : RangeExpression, Int == R.Bound { get }

    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Slice<Unicode.Scalar.UTF8View> { get }

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    @inlinable public func reversed() -> ReversedCollection<Unicode.Scalar.UTF8View>

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func map<T>(_ transform: (UTF8.CodeUnit) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func filter(_ isIncluded: (UTF8.CodeUnit) throws -> Bool) rethrows -> [UTF8.CodeUnit]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    @inlinable public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    @inlinable public func forEach(_ body: (UTF8.CodeUnit) throws -> Void) rethrows

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func first(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<UTF8.CodeUnit>) throws -> R) rethrows -> R?

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     var shorterIndices: [Set<String>.Index] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    ///
    /// - Complexity: O(1)
    @inlinable public func enumerated() -> EnumeratedSequence<Unicode.Scalar.UTF8View>

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional((key: "Coral", value: 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional((key: "Heliotrope", value: 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> UTF8.CodeUnit?

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func min() -> UTF8.CodeUnit?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @warn_unqualified_access
    @inlinable public func max() -> UTF8.CodeUnit?

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (UTF8.CodeUnit, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `possiblePrefix`.
    @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, UTF8.CodeUnit == PossiblePrefix.Element

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (UTF8.CodeUnit, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    ///
    /// - Complexity: O(*m*), where *m* is the lesser of the length of the
    ///   sequence and the length of `other`.
    @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, UTF8.CodeUnit == OtherSequence.Element

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(where predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// The following code uses this method to test whether all the names in an
    /// array have at least five characters:
    ///
    ///     let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    ///     let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    ///     // allHaveAtLeastFive == true
    ///
    /// If the sequence is empty, this method returns `true`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func allSatisfy(_ predicate: (UTF8.CodeUnit) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func contains(_ element: UTF8.CodeUnit) -> Bool

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, UTF8.CodeUnit) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    @inlinable public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, UTF8.CodeUnit) throws -> ()) rethrows -> Result

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func flatMap<SegmentOfResult>(_ transform: (UTF8.CodeUnit) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of non-optional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *n* is the length of this sequence
    ///   and *m* is the length of the result.
    @inlinable public func compactMap<ElementOfResult>(_ transform: (UTF8.CodeUnit) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements that compare equal.
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted() -> [UTF8.CodeUnit]

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element should be ordered before the second. The
    /// elements of the resulting array are ordered according to the given
    /// predicate.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not guaranteed to be stable. A stable sort
    /// preserves the relative order of elements for which
    /// `areInIncreasingOrder` does not establish an order.
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the sequence.
    @inlinable public func sorted(by areInIncreasingOrder: (UTF8.CodeUnit, UTF8.CodeUnit) throws -> Bool) rethrows -> [UTF8.CodeUnit]
}

/// Default implementations of core requirements
extension Unicode.Scalar.UTF8View {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    @inlinable public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    @inlinable public var first: UTF8.CodeUnit? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    @inlinable public var count: Int { get }
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Unicode.Scalar.UTF8View {

    /// Returns an iterator over the elements of the collection.
    @inlinable public func makeIterator() -> IndexingIterator<Unicode.Scalar.UTF8View>
}

/// Supply the default "slicing" `subscript` for `Collection` models
/// that accept the default associated `SubSequence`, `Slice<Self>`.
extension Unicode.Scalar.UTF8View {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(bounds: Range<Int>) -> Slice<Unicode.Scalar.UTF8View> { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Unicode.Scalar.UTF8View : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The position of the first code unit.
    @inlinable public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @inlinable public var endIndex: Int { get }

    /// Accesses the code unit at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    @inlinable public subscript(position: Int) -> UTF8.CodeUnit { get }

    /// A type representing the sequence's elements.
    public typealias Element = UTF8.CodeUnit

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Unicode.Scalar.UTF8View>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<Unicode.Scalar.UTF8View>
}

extension Unicode.Scalar.Properties {

    /// A Boolean value indicating whether the scalar is alphabetic.
    ///
    /// Alphabetic scalars are the primary units of alphabets and/or syllabaries.
    ///
    /// This property corresponds to the "Alphabetic" and the "Other_Alphabetic"
    /// properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isAlphabetic: Bool { get }

    /// A Boolean value indicating whether the scalar is an ASCII character
    /// commonly used for the representation of hexadecimal numbers.
    ///
    /// The only scalars for which this property is `true` are:
    ///
    /// * U+0030...U+0039: DIGIT ZERO...DIGIT NINE
    /// * U+0041...U+0046: LATIN CAPITAL LETTER A...LATIN CAPITAL LETTER F
    /// * U+0061...U+0066: LATIN SMALL LETTER A...LATIN SMALL LETTER F
    ///
    /// This property corresponds to the "ASCII_Hex_Digit" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isASCIIHexDigit: Bool { get }

    /// A Boolean value indicating whether the scalar is a format control
    /// character that has a specific function in the Unicode Bidrectional
    /// Algorithm.
    ///
    /// This property corresponds to the "Bidi_Control" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isBidiControl: Bool { get }

    /// A Boolean value indicating whether the scalar is mirrored in
    /// bidirectional text.
    ///
    /// This property corresponds to the "Bidi_Mirrored" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isBidiMirrored: Bool { get }

    /// A Boolean value indicating whether the scalar is a punctuation
    /// symbol explicitly called out as a dash in the Unicode Standard or a
    /// compatibility equivalent.
    ///
    /// This property corresponds to the "Dash" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isDash: Bool { get }

    /// A Boolean value indicating whether the scalar is a default-ignorable
    /// code point.
    ///
    /// Default-ignorable code points are those that should be ignored by default
    /// in rendering (unless explicitly supported). They have no visible glyph or
    /// advance width in and of themselves, although they may affect the display,
    /// positioning, or adornment of adjacent or surrounding characters.
    ///
    /// This property corresponds to the "Default_Ignorable_Code_Point" and the
    /// "Other_Default_Ignorable_Code_point" properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isDefaultIgnorableCodePoint: Bool { get }

    /// A Boolean value indicating whether the scalar is deprecated.
    ///
    /// Scalars are never removed from the Unicode Standard, but the usage of
    /// deprecated scalars is strongly discouraged.
    ///
    /// This property corresponds to the "Deprecated" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isDeprecated: Bool { get }

    /// A Boolean value indicating whether the scalar is a diacritic.
    ///
    /// Diacritics are scalars that linguistically modify the meaning of another
    /// scalar to which they apply. Scalars for which this property is `true` are
    /// frequently, but not always, combining marks or modifiers.
    ///
    /// This property corresponds to the "Diacritic" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isDiacritic: Bool { get }

    /// A Boolean value indicating whether the scalar's principal function is
    /// to extend the value or shape of a preceding alphabetic scalar.
    ///
    /// Typical extenders are length and iteration marks.
    ///
    /// This property corresponds to the "Extender" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isExtender: Bool { get }

    /// A Boolean value indicating whether the scalar is excluded from
    /// composition when performing Unicode normalization.
    ///
    /// This property corresponds to the "Full_Composition_Exclusion" property in
    /// the [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isFullCompositionExclusion: Bool { get }

    /// A Boolean value indicating whether the scalar is a grapheme base.
    ///
    /// A grapheme base can be thought of as a space-occupying glyph above or
    /// below which other non-spacing modifying glyphs can be applied. For
    /// example, when the character `é` is represented in its decomposed form,
    /// the grapheme base is "e" (U+0065 LATIN SMALL LETTER E) and it is followed
    /// by a single grapheme extender, U+0301 COMBINING ACUTE ACCENT.
    ///
    /// The set of scalars for which `isGraphemeBase` is `true` is disjoint by
    /// definition from the set for which `isGraphemeExtend` is `true`.
    ///
    /// This property corresponds to the "Grapheme_Base" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isGraphemeBase: Bool { get }

    /// A Boolean value indicating whether the scalar is a grapheme extender.
    ///
    /// A grapheme extender can be thought of primarily as a non-spacing glyph
    /// that is applied above or below another glyph. For example, when the
    /// character `é` is represented in its decomposed form, the grapheme base is
    /// "e" (U+0065 LATIN SMALL LETTER E) and it is followed by a single grapheme
    /// extender, U+0301 COMBINING ACUTE ACCENT.
    ///
    /// The set of scalars for which `isGraphemeExtend` is `true` is disjoint by
    /// definition from the set for which `isGraphemeBase` is `true`.
    ///
    /// This property corresponds to the "Grapheme_Extend" and the
    /// "Other_Grapheme_Extend" properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isGraphemeExtend: Bool { get }

    /// A Boolean value indicating whether the scalar is one that is commonly
    /// used for the representation of hexadecimal numbers or a compatibility
    /// equivalent.
    ///
    /// This property is `true` for all scalars for which `isASCIIHexDigit` is
    /// `true` as well as for their CJK halfwidth and fullwidth variants.
    ///
    /// This property corresponds to the "Hex_Digit" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isHexDigit: Bool { get }

    /// A Boolean value indicating whether the scalar is one which is
    /// recommended to be allowed to appear in a non-starting position in a
    /// programming language identifier.
    ///
    /// Applications that store identifiers in NFKC normalized form should instead
    /// use `isXIDContinue` to check whether a scalar is a valid identifier
    /// character.
    ///
    /// This property corresponds to the "ID_Continue" and the "Other_ID_Continue"
    /// properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isIDContinue: Bool { get }

    /// A Boolean value indicating whether the scalar is one which is
    /// recommended to be allowed to appear in a starting position in a
    /// programming language identifier.
    ///
    /// Applications that store identifiers in NFKC normalized form should instead
    /// use `isXIDStart` to check whether a scalar is a valid identifier
    /// character.
    ///
    /// This property corresponds to the "ID_Start" and the "Other_ID_Start"
    /// properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isIDStart: Bool { get }

    /// A Boolean value indicating whether the scalar is considered to be a
    /// CJKV (Chinese, Japanese, Korean, and Vietnamese) or other siniform
    /// (Chinese writing-related) ideograph.
    ///
    /// This property roughly defines the class of "Chinese characters" and does
    /// not include characters of other logographic scripts such as Cuneiform or
    /// Egyptian Hieroglyphs.
    ///
    /// This property corresponds to the "Ideographic" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isIdeographic: Bool { get }

    /// A Boolean value indicating whether the scalar is an ideographic
    /// description character that determines how the two ideographic characters
    /// or ideographic description sequences that follow it are to be combined to
    /// form a single character.
    ///
    /// Ideographic description characters are technically printable characters,
    /// but advanced rendering engines may use them to approximate ideographs that
    /// are otherwise unrepresentable.
    ///
    /// This property corresponds to the "IDS_Binary_Operator" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isIDSBinaryOperator: Bool { get }

    /// A Boolean value indicating whether the scalar is an ideographic
    /// description character that determines how the three ideographic characters
    /// or ideographic description sequences that follow it are to be combined to
    /// form a single character.
    ///
    /// Ideographic description characters are technically printable characters,
    /// but advanced rendering engines may use them to approximate ideographs that
    /// are otherwise unrepresentable.
    ///
    /// This property corresponds to the "IDS_Trinary_Operator" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isIDSTrinaryOperator: Bool { get }

    /// A Boolean value indicating whether the scalar is a format control
    /// character that has a specific function in controlling cursive joining and
    /// ligation.
    ///
    /// There are two scalars for which this property is `true`:
    ///
    /// * When U+200C ZERO WIDTH NON-JOINER is inserted between two characters, it
    ///   directs the rendering engine to render them separately/disconnected when
    ///   it might otherwise render them as a ligature. For example, a rendering
    ///   engine might display "fl" in English as a connected glyph; inserting the
    ///   zero width non-joiner would force them to be rendered as disconnected
    ///   glyphs.
    ///
    /// * When U+200D ZERO WIDTH JOINER is inserted between two characters, it
    ///   directs the rendering engine to render them as a connected glyph when it
    ///   would otherwise render them independently. The zero width joiner is also
    ///   used to construct complex emoji from sequences of base emoji characters.
    ///   For example, the various "family" emoji are encoded as sequences of man,
    ///   woman, or child emoji that are interleaved with zero width joiners.
    ///
    /// This property corresponds to the "Join_Control" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isJoinControl: Bool { get }

    /// A Boolean value indicating whether the scalar requires special handling
    /// for operations involving ordering, such as sorting and searching.
    ///
    /// This property applies to a small number of spacing vowel letters occurring
    /// in some Southeast Asian scripts like Thai and Lao, which use a visual
    /// order display model. Such letters are stored in text ahead of
    /// syllable-initial consonants.
    ///
    /// This property corresponds to the "Logical_Order_Exception" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isLogicalOrderException: Bool { get }

    /// A Boolean value indicating whether the scalar's letterform is
    /// considered lowercase.
    ///
    /// This property corresponds to the "Lowercase" and the "Other_Lowercase"
    /// properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isLowercase: Bool { get }

    /// A Boolean value indicating whether the scalar is one that naturally
    /// appears in mathematical contexts.
    ///
    /// The set of scalars for which this property is `true` includes mathematical
    /// operators and symbols as well as specific Greek and Hebrew letter
    /// variants that are categorized as symbols. Notably, it does _not_ contain
    /// the standard digits or Latin/Greek letter blocks; instead, it contains the
    /// mathematical Latin, Greek, and Arabic letters and numbers defined in the
    /// Supplemental Multilingual Plane.
    ///
    /// This property corresponds to the "Math" and the "Other_Math" properties in
    /// the [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isMath: Bool { get }

    /// A Boolean value indicating whether the scalar is permanently reserved
    /// for internal use.
    ///
    /// This property corresponds to the "Noncharacter_Code_Point" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isNoncharacterCodePoint: Bool { get }

    /// A Boolean value indicating whether the scalar is one that is used in
    /// writing to surround quoted text.
    ///
    /// This property corresponds to the "Quotation_Mark" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isQuotationMark: Bool { get }

    /// A Boolean value indicating whether the scalar is a radical component of
    /// CJK characters, Tangut characters, or Yi syllables.
    ///
    /// These scalars are often the components of ideographic description
    /// sequences, as defined by the `isIDSBinaryOperator` and
    /// `isIDSTrinaryOperator` properties.
    ///
    /// This property corresponds to the "Radical" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isRadical: Bool { get }

    /// A Boolean value indicating whether the scalar has a "soft dot" that
    /// disappears when a diacritic is placed over the scalar.
    ///
    /// For example, "i" is soft dotted because the dot disappears when adding an
    /// accent mark, as in "í".
    ///
    /// This property corresponds to the "Soft_Dotted" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isSoftDotted: Bool { get }

    /// A Boolean value indicating whether the scalar is a punctuation symbol
    /// that typically marks the end of a textual unit.
    ///
    /// This property corresponds to the "Terminal_Punctuation" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isTerminalPunctuation: Bool { get }

    /// A Boolean value indicating whether the scalar is one of the unified
    /// CJK ideographs in the Unicode Standard.
    ///
    /// This property is false for CJK punctuation and symbols, as well as for
    /// compatibility ideographs (which canonically decompose to unified
    /// ideographs).
    ///
    /// This property corresponds to the "Unified_Ideograph" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isUnifiedIdeograph: Bool { get }

    /// A Boolean value indicating whether the scalar's letterform is
    /// considered uppercase.
    ///
    /// This property corresponds to the "Uppercase" and the "Other_Uppercase"
    /// properties in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isUppercase: Bool { get }

    /// A Boolean value indicating whether the scalar is a whitespace
    /// character.
    ///
    /// This property is `true` for scalars that are spaces, separator characters,
    /// and other control characters that should be treated as whitespace for the
    /// purposes of parsing text elements.
    ///
    /// This property corresponds to the "White_Space" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isWhitespace: Bool { get }

    /// A Boolean value indicating whether the scalar is one which is
    /// recommended to be allowed to appear in a non-starting position in a
    /// programming language identifier, with adjustments made for NFKC normalized
    /// form.
    ///
    /// The set of scalars `[:XID_Continue:]` closes the set `[:ID_Continue:]`
    /// under NFKC normalization by removing any scalars whose normalized form is
    /// not of the form `[:ID_Continue:]*`.
    ///
    /// This property corresponds to the "XID_Continue" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isXIDContinue: Bool { get }

    /// A Boolean value indicating whether the scalar is one which is
    /// recommended to be allowed to appear in a starting position in a
    /// programming language identifier, with adjustments made for NFKC normalized
    /// form.
    ///
    /// The set of scalars `[:XID_Start:]` closes the set `[:ID_Start:]` under
    /// NFKC normalization by removing any scalars whose normalized form is not of
    /// the form `[:ID_Start:] [:ID_Continue:]*`.
    ///
    /// This property corresponds to the "XID_Start" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isXIDStart: Bool { get }

    /// A Boolean value indicating whether the scalar is a punctuation mark
    /// that generally marks the end of a sentence.
    ///
    /// This property corresponds to the "Sentence_Terminal" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isSentenceTerminal: Bool { get }

    /// A Boolean value indicating whether the scalar is a variation selector.
    ///
    /// Variation selectors allow rendering engines that support them to choose
    /// different glyphs to display for a particular code point.
    ///
    /// This property corresponds to the "Variation_Selector" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isVariationSelector: Bool { get }

    /// A Boolean value indicating whether the scalar is recommended to have
    /// syntactic usage in patterns represented in source code.
    ///
    /// This property corresponds to the "Pattern_Syntax" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isPatternSyntax: Bool { get }

    /// A Boolean value indicating whether the scalar is recommended to be
    /// treated as whitespace when parsing patterns represented in source code.
    ///
    /// This property corresponds to the "Pattern_White_Space" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isPatternWhitespace: Bool { get }

    /// A Boolean value indicating whether the scalar is considered to be
    /// either lowercase, uppercase, or titlecase.
    ///
    /// Though similar in name, this property is *not* equivalent to
    /// `changesWhenCaseMapped`. The set of scalars for which `isCased` is `true`
    /// is a superset of those for which `changesWhenCaseMapped` is `true`. For
    /// example, the Latin small capitals that are used by the International
    /// Phonetic Alphabet have a case, but do not change when they are mapped to
    /// any of the other cases.
    ///
    /// This property corresponds to the "Cased" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isCased: Bool { get }

    /// A Boolean value indicating whether the scalar is ignored for casing
    /// purposes.
    ///
    /// This property corresponds to the "Case_Ignorable" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var isCaseIgnorable: Bool { get }

    /// A Boolean value indicating whether the scalar's normalized form differs
    /// from the `lowercaseMapping` of each constituent scalar.
    ///
    /// This property corresponds to the "Changes_When_Lowercased" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenLowercased: Bool { get }

    /// A Boolean value indicating whether the scalar's normalized form differs
    /// from the `uppercaseMapping` of each constituent scalar.
    ///
    /// This property corresponds to the "Changes_When_Uppercased" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenUppercased: Bool { get }

    /// A Boolean value indicating whether the scalar's normalized form differs
    /// from the `titlecaseMapping` of each constituent scalar.
    ///
    /// This property corresponds to the "Changes_When_Titlecased" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenTitlecased: Bool { get }

    /// A Boolean value indicating whether the scalar's normalized form differs
    /// from the case-fold mapping of each constituent scalar.
    ///
    /// This property corresponds to the "Changes_When_Casefolded" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenCaseFolded: Bool { get }

    /// A Boolean value indicating whether the scalar may change when it
    /// undergoes case mapping.
    ///
    /// This property is `true` whenever one or more of `changesWhenLowercased`,
    /// `changesWhenUppercased`, or `changesWhenTitlecased` are `true`.
    ///
    /// This property corresponds to the "Changes_When_Casemapped" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenCaseMapped: Bool { get }

    /// A Boolean value indicating whether the scalar is one that is not
    /// identical to its NFKC case-fold mapping.
    ///
    /// This property corresponds to the "Changes_When_NFKC_Casefolded" property
    /// in the [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var changesWhenNFKCCaseFolded: Bool { get }

    /// A Boolean value indicating whether the scalar has an emoji
    /// presentation, whether or not it is the default.
    ///
    /// This property is true for scalars that are rendered as emoji by default
    /// and also for scalars that have a non-default emoji rendering when followed
    /// by U+FE0F VARIATION SELECTOR-16. This includes some scalars that are not
    /// typically considered to be emoji:
    ///
    ///     let scalars: [Unicode.Scalar] = ["😎", "$", "0"]
    ///     for s in scalars {
    ///         print(s, "-->", s.properties.isEmoji)
    ///     }
    ///     // 😎 --> true
    ///     // $ --> false
    ///     // 0 --> true
    ///
    /// The final result is true because the ASCII digits have non-default emoji
    /// presentations; some platforms render these with an alternate appearance.
    ///
    /// Because of this behavior, testing `isEmoji` alone on a single scalar is
    /// insufficient to determine if a unit of text is rendered as an emoji; a
    /// correct test requires inspecting multiple scalars in a `Character`. In
    /// addition to checking whether the base scalar has `isEmoji == true`, you
    /// must also check its default presentation (see `isEmojiPresentation`) and
    /// determine whether it is followed by a variation selector that would modify
    /// the presentation.
    ///
    /// This property corresponds to the "Emoji" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
    public var isEmoji: Bool { get }

    /// A Boolean value indicating whether the scalar is one that should be
    /// rendered with an emoji presentation, rather than a text presentation, by
    /// default.
    ///
    /// Scalars that have default to emoji presentation can be followed by
    /// U+FE0E VARIATION SELECTOR-15 to request the text presentation of the
    /// scalar instead. Likewise, scalars that default to text presentation can
    /// be followed by U+FE0F VARIATION SELECTOR-16 to request the emoji
    /// presentation.
    ///
    /// This property corresponds to the "Emoji_Presentation" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
    public var isEmojiPresentation: Bool { get }

    /// A Boolean value indicating whether the scalar is one that can modify
    /// a base emoji that precedes it.
    ///
    /// The Fitzpatrick skin types are examples of emoji modifiers; they change
    /// the appearance of the preceding emoji base (that is, a scalar for which
    /// `isEmojiModifierBase` is true) by rendering it with a different skin tone.
    ///
    /// This property corresponds to the "Emoji_Modifier" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
    public var isEmojiModifier: Bool { get }

    /// A Boolean value indicating whether the scalar is one whose appearance
    /// can be changed by an emoji modifier that follows it.
    ///
    /// This property corresponds to the "Emoji_Modifier_Base" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    @available(macOS 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
    public var isEmojiModifierBase: Bool { get }

    /// The lowercase mapping of the scalar.
    ///
    /// This property is a `String`, not a `Unicode.Scalar` or `Character`,
    /// because some mappings may transform a scalar into multiple scalars or
    /// graphemes. For example, the character "İ" (U+0130 LATIN CAPITAL LETTER I
    /// WITH DOT ABOVE) becomes two scalars (U+0069 LATIN SMALL LETTER I, U+0307
    /// COMBINING DOT ABOVE) when converted to lowercase.
    ///
    /// This property corresponds to the "Lowercase_Mapping" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var lowercaseMapping: String { get }

    /// The titlecase mapping of the scalar.
    ///
    /// This property is a `String`, not a `Unicode.Scalar` or `Character`,
    /// because some mappings may transform a scalar into multiple scalars or
    /// graphemes. For example, the ligature "ﬁ" (U+FB01 LATIN SMALL LIGATURE FI)
    /// becomes "Fi" (U+0046 LATIN CAPITAL LETTER F, U+0069 LATIN SMALL LETTER I)
    /// when converted to titlecase.
    ///
    /// This property corresponds to the "Titlecase_Mapping" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var titlecaseMapping: String { get }

    /// The uppercase mapping of the scalar.
    ///
    /// This property is a `String`, not a `Unicode.Scalar` or `Character`,
    /// because some mappings may transform a scalar into multiple scalars or
    /// graphemes. For example, the German letter "ß" (U+00DF LATIN SMALL LETTER
    /// SHARP S) becomes "SS" (U+0053 LATIN CAPITAL LETTER S, U+0053 LATIN CAPITAL
    /// LETTER S) when converted to uppercase.
    ///
    /// This property corresponds to the "Uppercase_Mapping" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var uppercaseMapping: String { get }

    /// The earliest version of the Unicode Standard in which the scalar was
    /// assigned.
    ///
    /// This value is `nil` for code points that have not yet been assigned.
    ///
    /// This property corresponds to the "Age" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var age: Unicode.Version? { get }

    /// The general category (most usual classification) of the scalar.
    ///
    /// This property corresponds to the "General_Category" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var generalCategory: Unicode.GeneralCategory { get }

    /// The published name of the scalar.
    ///
    /// Some scalars, such as control characters, do not have a value for this
    /// property in the Unicode Character Database. For such scalars, this
    /// property is `nil`.
    ///
    /// This property corresponds to the "Name" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var name: String? { get }

    /// The normative formal alias of the scalar.
    ///
    /// The name of a scalar is immutable and never changed in future versions of
    /// the Unicode Standard. The `nameAlias` property is provided to issue
    /// corrections if a name was issued erroneously. For example, the `name` of
    /// U+FE18 is "PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET"
    /// (note that "BRACKET" is misspelled). The `nameAlias` property then
    /// contains the corrected name.
    ///
    /// If a scalar has no alias, this property is `nil`.
    ///
    /// This property corresponds to the "Name_Alias" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var nameAlias: String? { get }

    /// The canonical combining class of the scalar.
    ///
    /// This property corresponds to the "Canonical_Combining_Class" property in
    /// the [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var canonicalCombiningClass: Unicode.CanonicalCombiningClass { get }
}

/// Numeric properties of scalars.
extension Unicode.Scalar.Properties {

    /// The numeric type of the scalar.
    ///
    /// For scalars that represent a number, `numericType` is the numeric type
    /// of the scalar. For all other scalars, this property is `nil`.
    ///
    ///     let scalars: [Unicode.Scalar] = ["4", "④", "⅕", "X"]
    ///     for scalar in scalars {
    ///         print(scalar, "-->", scalar.properties.numericType)
    ///     }
    ///     // 4 --> Optional(Swift.Unicode.NumericType.decimal)
    ///     // ④ --> Optional(Swift.Unicode.NumericType.digit)
    ///     // ⅕ --> Optional(Swift.Unicode.NumericType.numeric)
    ///     // X --> nil
    ///
    /// This property corresponds to the "Numeric_Type" property in the
    /// [Unicode Standard](http://www.unicode.org/versions/latest/).
    public var numericType: Unicode.NumericType? { get }

    /// The numeric value of the scalar.
    ///
    /// For scalars that represent a numeric value, `numericValue` is the whole
    /// or fractional value. For all other scalars, this property is `nil`.
    ///
    ///     let scalars: [Unicode.Scalar] = ["4", "④", "⅕", "X"]
    ///     for scalar in scalars {
    ///         print(scalar, "-->", scalar.properties.numericValue)
    ///     }
    ///     // 4 --> Optional(4.0)
    ///     // ④ --> Optional(4.0)
    ///     // ⅕ --> Optional(0.2)
    ///     // X --> nil
    ///
    /// This property corresponds to the "Numeric_Value" property in the [Unicode
    /// Standard](http://www.unicode.org/versions/latest/).
    public var numericValue: Double? { get }
}

extension Unicode.UTF16.ForwardParser {

    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<_UIntBuffer<UInt16>> where I : IteratorProtocol, I.Element == UInt16
}

extension Unicode.UTF16.ForwardParser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF16
}

extension Unicode.UTF16.ReverseParser {

    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<_UIntBuffer<UInt16>> where I : IteratorProtocol, I.Element == UInt16
}

extension Unicode.UTF16.ReverseParser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF16
}

extension Unicode.UTF8.ForwardParser {

    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<_ValidUTF8Buffer> where I : IteratorProtocol, I.Element == UInt8
}

extension Unicode.UTF8.ForwardParser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF8
}

extension Unicode.UTF8.ReverseParser {

    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<_ValidUTF8Buffer> where I : IteratorProtocol, I.Element == UInt8
}

extension Unicode.UTF8.ReverseParser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF8
}

extension Unicode.UTF32.Parser : Unicode.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF32

    /// Parses a single Unicode scalar value from `input`.
    @inlinable public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Unicode.UTF32.Parser.Encoding.EncodedScalar> where I : IteratorProtocol, I.Element == UInt32
}


